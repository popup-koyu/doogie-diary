<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doogie - Personal Diary</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap');

        @font-face {
            font-family: 'NeoDunggeunmo';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.3/NeoDunggeunmo.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #ffffff;
            font-family: 'VT323', monospace;
            font-size: 20px;
            line-height: 1.4;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(circle, #00ff00 0.5px, transparent 0.5px);
            background-size: 50px 50px;
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
            animation: noise 0.5s steps(8) infinite;
        }

        @keyframes noise {
            0% {
                opacity: 0.02;
                background-position: 0 0;
            }
            10% {
                opacity: 0.04;
                background-position: -5px -10px;
            }
            20% {
                opacity: 0.01;
                background-position: 15px 5px;
            }
            30% {
                opacity: 0.03;
                background-position: -10px 15px;
            }
            40% {
                opacity: 0.02;
                background-position: 8px -8px;
            }
            50% {
                opacity: 0.01;
                background-position: -15px 12px;
            }
            60% {
                opacity: 0.03;
                background-position: 12px -5px;
            }
            70% {
                opacity: 0.02;
                background-position: -8px 8px;
            }
            80% {
                opacity: 0.01;
                background-position: 5px 15px;
            }
            90% {
                opacity: 0.02;
                background-position: -12px -12px;
            }
            100% {
                opacity: 0.01;
                background-position: 0 0;
            }
        }

        .screen {
            width: 100vw;
            height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .header {
            border: 1px solid #00ff00;
            padding: 10px;
            margin-bottom: 10px;
            text-align: center;
            background: #008800;
            color: #00ff00;
            box-shadow:
                0 0 0 1px #00ff00,
                0 0 0 2px #000000,
                0 0 0 3px #00ff00;
        }

        /* Title Screen */
        .title-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        /* Twinkling Stars Background */
        .stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ff00;
            box-shadow: 0 0 2px #00ff00;
            animation: twinkle 3s infinite;
        }

        @keyframes twinkle {
            0%, 100% {
                opacity: 0.2;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.5);
            }
        }

        .logo {
            font-family: 'Press Start 2P', monospace;
            font-size: 82px;
            color: #00ff00;
            text-shadow: 6px 6px 0px #008800;
            margin-bottom: 60px;
            letter-spacing: 12px;
            position: relative;
            animation: glitch 3s infinite;
            z-index: 1;
        }

        @keyframes glitch {
            0%, 90%, 100% {
                text-shadow: 6px 6px 0px #008800;
                transform: translate(0);
            }
            92% {
                text-shadow:
                    -2px 0 0 #ff00ff,
                    2px 0 0 #00ffff,
                    6px 6px 0px #008800;
                transform: translate(-2px, 0);
            }
            94% {
                text-shadow:
                    2px 0 0 #ff00ff,
                    -2px 0 0 #00ffff,
                    6px 6px 0px #008800;
                transform: translate(2px, 0);
            }
            96% {
                text-shadow:
                    -2px 0 0 #ff00ff,
                    2px 0 0 #00ffff,
                    6px 6px 0px #008800;
                transform: translate(0);
            }
        }

        .main-menu {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .menu-item {
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 24px;
            color: #00ff00;
            cursor: pointer;
            padding: 6px 20px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.2s;
            position: relative;
            z-index: 1;
        }

        .menu-item:hover,
        .menu-item.selected {
            background: #00ff00;
            color: #000000;
            border: 2px solid #00ff00;
        }

        .menu-item::before {
            content: '';
            margin-right: 10px;
        }

        .menu-item.selected::before {
            content: '▶ ';
        }

        .app-container {
            display: none;
            flex: 1;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .main-container {
            flex: 1;
            border: 1px solid #00ff00;
            display: flex;
            flex-direction: column;
            background: #000000;
            overflow: hidden;
            box-shadow:
                0 0 0 1px #00ff00,
                0 0 0 2px #000000,
                0 0 0 3px #00ff00;
        }

        .diary-container {
            display: flex;
            flex-direction: column;
            background: #000000;
            overflow: hidden;
            margin: auto;
            width: 100%;
            flex: 1;
            min-height: 0;
        }

        .menu-bar {
            background: #000000;
            color: #00ff00;
            padding: 10px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 20px;
            flex-shrink: 0;
            position: sticky;
            top: 0;
            z-index: 100;
            border: none;
            border-bottom: 1px solid #00ff00;
        }

        .menu-bar * {
            border: none;
            text-decoration: none;
        }

        .menu-item-wrapper {
            position: relative;
        }

        .menu-bar .menu-item-top {
            cursor: pointer;
            transition: color 0.2s;
            padding: 5px 10px;
            border: none;
            text-decoration: none;
        }

        .menu-bar .menu-item-top:hover {
            color: #ffffff;
        }

        /* Mode Toggle Button */
        .mode-toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
            padding-right: 10px;
        }

        .mode-toggle-label {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #00ff00;
            min-width: 80px;
            text-align: right;
        }

        .mode-toggle-label.markdown-mode {
            color: #55ff55;
        }

        .mode-toggle-btn {
            width: 50px;
            height: 24px;
            background: #003300;
            border: 2px solid #00ff00;
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
        }

        .mode-toggle-btn:hover {
            background: #004400;
        }

        .mode-toggle-btn.markdown-active {
            background: #003300;
            border-color: #55ff55;
        }

        .mode-toggle-indicator {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: #00ff00;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px #00ff00;
        }

        .mode-toggle-btn.markdown-active .mode-toggle-indicator {
            left: 28px;
            background: #55ff55;
            box-shadow: 0 0 5px #55ff55;
        }

        /* Markdown Editor Styles */
        .markdown-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .markdown-editor-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .markdown-toolbar {
            display: flex;
            gap: 5px;
            padding: 8px;
            background: #001a00;
            border-bottom: 1px solid #00ff00;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .md-tool-btn {
            background: #002200;
            border: 1px solid #00aa00;
            color: #00ff00;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 16px;
            transition: all 0.2s;
        }

        .md-tool-btn:hover {
            background: #004400;
            color: #ffffff;
            border-color: #00ff00;
        }

        .md-preview-btn {
            background: #220022;
            border-color: #aa00aa;
            color: #ff55ff;
        }

        .md-preview-btn:hover {
            background: #440044;
            border-color: #ff55ff;
        }

        .md-preview-btn.active {
            background: #550055;
            border-color: #ff55ff;
            box-shadow: 0 0 5px #ff55ff;
        }

        .md-toolbar-separator {
            width: 1px;
            background: #004400;
            margin: 0 5px;
        }

        .markdown-edit-area {
            flex: 1;
            display: flex;
            min-height: 0;
            overflow: hidden;
        }

        .markdown-editor {
            flex: 1;
            background: transparent;
            border: none;
            color: #00ff00;
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 18px;
            line-height: 1.6;
            resize: none;
            outline: none;
            padding: 15px;
            overflow-y: auto;
            min-width: 0;
            min-height: 0;
        }

        .markdown-editor::placeholder {
            color: #004400;
        }

        .markdown-preview {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: #001100;
            border-left: 1px solid #00aa00;
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 18px;
            line-height: 1.6;
            min-width: 0;
            min-height: 0;
        }

        /* Markdown Rendering - DOS Green Monotone Style */
        .markdown-preview h1, .markdown-preview h2, .markdown-preview h3,
        .markdown-preview h4, .markdown-preview h5, .markdown-preview h6 {
            color: #00ff00;
            font-family: 'NeoDunggeunmo', monospace;
            margin: 20px 0 10px 0;
            font-weight: normal;
        }

        .markdown-preview h1 { font-size: 28px; }
        .markdown-preview h2 { font-size: 24px; }
        .markdown-preview h3 { font-size: 20px; }
        .markdown-preview h4 { font-size: 18px; }
        .markdown-preview h5 { font-size: 16px; }
        .markdown-preview h6 { font-size: 14px; }

        .markdown-preview p {
            color: #00ff00;
            margin: 10px 0;
        }

        .markdown-preview strong {
            color: #00ff00;
            font-weight: bold;
            text-shadow: 0 0 3px #00ff00;
        }

        .markdown-preview em {
            color: #00aa00;
            font-style: italic;
        }

        .markdown-preview code {
            background: #1a0a00;
            color: #ff8800;
            padding: 2px 6px;
            border: none;
            font-family: 'NeoDunggeunmo', monospace;
        }

        .markdown-preview pre {
            background: #1a0a00;
            border: none;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }

        .markdown-preview pre code {
            background: transparent;
            padding: 0;
            border: none;
            color: #ff8800;
        }

        .markdown-preview a {
            color: #00ff00;
            text-decoration: underline;
        }

        .markdown-preview a:hover {
            color: #55ff55;
            text-shadow: 0 0 5px #00ff00;
        }

        .markdown-preview blockquote {
            border-left: 3px solid #00aa00;
            padding-left: 15px;
            margin: 15px 0;
            color: #008800;
            background: #001100;
            padding: 10px 15px;
        }

        .markdown-preview ul, .markdown-preview ol {
            color: #00ff00;
            margin: 10px 0;
            padding-left: 25px;
        }

        .markdown-preview li {
            margin: 5px 0;
        }

        .markdown-preview table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }

        .markdown-preview th {
            background: #002200;
            color: #00ff00;
            padding: 8px;
            border: 1px solid #00aa00;
            text-align: left;
        }

        .markdown-preview td {
            padding: 8px;
            border: 1px solid #004400;
            color: #00ff00;
        }

        .markdown-preview tr:nth-child(even) {
            background: #001100;
        }

        .markdown-preview hr {
            border: none;
            border-top: 1px solid #00aa00;
            margin: 20px 0;
        }

        .markdown-preview del {
            color: #006600;
            text-decoration: line-through;
        }

        /* Mermaid Diagram Styling */
        .markdown-preview .mermaid {
            background: #001a00;
            padding: 15px;
            border: 1px solid #00aa00;
            margin: 15px 0;
            text-align: center;
        }

        .diary-list-panel {
            position: fixed;
            top: 60px;
            right: 20px;
            background: #000000;
            border: none;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            z-index: 9999;
            min-width: 300px;
        }

        .diary-list-panel.open {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #00ff00;
        }

        .diary-list-panel .list-item {
            padding: 10px 15px;
            border-bottom: 1px solid #004400;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            transition: background 0.2s;
        }

        .diary-list-panel .list-item:hover {
            background: #003300;
        }

        /* Picture dropdown menu */
        .picture-menu-panel {
            position: absolute;
            top: 100%;
            left: 0;
            background: #000000;
            border: none;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            z-index: 1000;
            min-width: 200px;
        }

        .picture-menu-panel.open {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #00ff00;
        }

        .picture-menu-panel .menu-option {
            padding: 10px 15px;
            border-bottom: 1px solid #004400;
            cursor: pointer;
            color: #00ff00;
            transition: background 0.2s;
            font-family: 'NeoDunggeunmo', monospace;
        }

        .picture-menu-panel .menu-option:hover {
            background: #003300;
        }

        .diary-list-panel .list-date {
            color: #00ff00;
            min-width: 100px;
        }

        .diary-list-panel .list-preview {
            color: #008800;
            flex: 1;
            margin-left: 15px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .content {
            flex: 1;
            padding: 20px;
            overflow: hidden;
            display: none;
            flex-direction: column;
            background: #000000;
            border: none;
            border-top: none;
            min-height: 0;
        }

        .date-header {
            font-size: 36px;
            margin-bottom: 20px;
            color: #00ff00;
            font-family: 'VT323', monospace;
            border: none;
            flex-shrink: 0;
        }

        .editor {
            flex: 1;
            background: transparent;
            border: none;
            color: #00ff00;
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 20px;
            line-height: 1.6;
            resize: none;
            outline: none;
            caret-color: transparent;
            position: relative;
            overflow-y: auto;
            min-height: 0;
        }

        .editor::placeholder {
            color: transparent;
        }

        .editor-wrapper {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: row;
            gap: 20px;
            min-height: 0;
            overflow: hidden;
        }

        .editor-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            min-height: 0;
            overflow: hidden;
        }

        .images-section {
            flex: 1;
            display: none;  /* Hidden by default */
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            min-height: 0;
        }

        .images-section.has-images {
            display: flex;  /* Show when images exist */
            border-left: 1px solid #00ff00;
            padding-left: 20px;
        }

        .images-container {
            display: grid;
            gap: 10px;
            width: 100%;
            height: 100%;
            grid-auto-rows: 1fr;
        }

        /* 1장: 전체 */
        .images-container[data-image-count="1"] {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
        }

        /* 2장: 세로로 2개 */
        .images-container[data-image-count="2"] {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr 1fr;
        }

        /* 3장: 상단 1개, 하단 2개 */
        .images-container[data-image-count="3"] {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }

        .images-container[data-image-count="3"] .image-item:first-child {
            grid-column: 1 / 3;
        }

        /* 4장 이상: 2x2 격자 */
        .images-container[data-image-count="4"],
        .images-container[data-image-count="5"],
        .images-container[data-image-count="6"],
        .images-container[data-image-count="7"],
        .images-container[data-image-count="8"],
        .images-container[data-image-count="9"] {
            grid-template-columns: 1fr 1fr;
            grid-auto-rows: 1fr;
        }

        .image-item {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 0;
        }

        .image-item img {
            display: block;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
            object-fit: contain;
            cursor: pointer;
        }

        .image-item .remove-image {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            background: #00ff00;
            color: #000000;
            border: 2px solid #00ff00;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .image-item:hover .remove-image {
            opacity: 1;
        }

        .image-item .remove-image:hover {
            background: #ff0000;
            border-color: #ff0000;
            color: #000000;
        }


        .cursor {
            position: absolute;
            width: 12px;
            height: 24px;
            background: #00ff00;
            pointer-events: none;
            z-index: 10;
            animation: cursorBlink 0.69s step-end infinite;
        }

        @keyframes cursorBlink {
            0%, 50% {
                opacity: 1;
            }
            51%, 100% {
                opacity: 0;
            }
        }

        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .image-modal.active {
            display: flex;
        }

        .image-modal img {
            max-width: 90vw;
            max-height: 90vh;
            image-rendering: pixelated;
            border: 3px solid #00ff00;
            clip-path: inset(0 0 100% 0);
            transition: none;
        }

        .image-modal img.scanning {
            animation: scanReveal 1.5s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
        }

        @keyframes scanReveal {
            0% {
                clip-path: inset(0 0 100% 0);
            }
            100% {
                clip-path: inset(0 0 0% 0);
            }
        }

        /* Scanline effect overlay */
        .image-modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(to bottom,
                rgba(0, 255, 0, 0.8) 0%,
                rgba(0, 255, 0, 0.3) 50%,
                rgba(0, 255, 0, 0) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 1001;
        }

        .image-modal.active::before {
            animation: scanline 1.5s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
        }

        @keyframes scanline {
            0% {
                opacity: 1;
                top: 0;
            }
            95% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                top: 100%;
            }
        }

        .image-modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff00;
            font-size: 48px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            text-shadow: 2px 2px 0 #000000;
        }

        .image-modal-close:hover {
            color: #ff0000;
        }

        .status-bar {
            background: #000000;
            color: #00ff00;
            padding: 5px 10px;
            border-top: 1px solid #00ff00;
            display: flex;
            justify-content: space-between;
            flex-shrink: 0;
            flex-grow: 0;
            height: 30px;
            min-height: 30px;
            max-height: 30px;
        }

        .entry-list {
            display: none;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
        }

        .entry-item {
            padding: 10px;
            border: 1px solid #00ff00;
            cursor: pointer;
            transition: background 0.2s;
        }

        .entry-item:hover {
            background: #003300;
        }

        .entry-item .entry-date {
            color: #00ff00;
            font-size: 22px;
        }

        .entry-item .entry-preview {
            color: #008800;
            margin-top: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .mode-view {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .mode-list {
            display: none;
        }

        .list-footer {
            margin-top: 30px;
            padding: 20px;
            text-align: center;
            border-top: 1px solid #00ff00;
        }

        .settings-link-button {
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 10px 30px;
            font-family: 'VT323', monospace;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-link-button:hover {
            background: #00ff00;
            color: #000000;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.6);
        }

        /* Calendar View - Split Layout */
        .calendar-container {
            display: none;
            flex-direction: row;
            gap: 0;
            overflow: hidden;
        }

        .calendar-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            border-right: 1px solid #00ff00;
            overflow-y: auto;
        }

        .calendar-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .calendar-nav-btn {
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 5px 15px;
            font-family: 'VT323', monospace;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .calendar-nav-btn:hover {
            background: #00ff00;
            color: #000000;
        }

        .calendar-title {
            font-family: 'VT323', monospace;
            font-size: 24px;
            color: #00ff00;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
        }

        .calendar-day-header {
            text-align: center;
            font-family: 'VT323', monospace;
            font-size: 16px;
            color: #00ff00;
            padding: 8px;
            border-bottom: 1px solid #00ff00;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid #003300;
            background: #000000;
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #008800;
            cursor: default;
            position: relative;
            transition: all 0.2s;
        }

        .calendar-day.other-month {
            color: #003300;
        }

        .calendar-day.today {
            border: 2px solid #00ff00;
            color: #00ff00;
        }

        .calendar-day.has-entry {
            cursor: pointer;
        }

        .calendar-day.has-entry:hover {
            background: #003300;
            color: #00ff00;
        }

        .calendar-day .entry-dot {
            position: absolute;
            bottom: 4px;
            width: 4px;
            height: 4px;
            background: #00ff00;
            border-radius: 50%;
        }

        .calendar-day.has-entry:hover .entry-dot {
            background: #00ff00;
            box-shadow: 0 0 5px #00ff00;
        }

        .calendar-list-section {
            padding: 20px;
        }

        .calendar-list-title {
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: #00ff00;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #00ff00;
        }

        .blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #000000;
        }

        ::-webkit-scrollbar-thumb {
            background: #00ff00;
        }

        .help-screen {
            display: none;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
        }

        .help-title {
            color: #00ff00;
            font-size: 24px;
            margin-bottom: 10px;
        }

        .help-item {
            margin-left: 20px;
            color: #00ff00;
        }

        /* Settings Screen */
        .settings-screen {
            display: none;
            flex-direction: column;
            gap: 20px;
            padding: 40px;
            align-items: center;
        }

        .settings-title {
            color: #00ff00;
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0px #008800;
        }

        .settings-section {
            width: 100%;
            max-width: 600px;
            border: 2px solid #00ff00;
            padding: 30px;
            background: rgba(0, 50, 0, 0.3);
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .setting-label {
            color: #00ff00;
            font-size: 20px;
            font-family: 'VT323', monospace;
            text-align: center;
        }

        .setting-control {
            display: flex;
            gap: 20px;
        }

        .lang-button {
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 12px 30px;
            font-family: 'VT323', monospace;
            font-size: 22px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 120px;
        }

        .lang-button:hover {
            background: #00ff00;
            color: #000000;
        }

        .lang-button.active {
            background: #00ff00;
            color: #000000;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
        }

        .settings-footer {
            color: #00aa00;
            font-size: 18px;
            margin-top: 20px;
        }

        /* Credits Screen - Retro Game Style */
        .credits-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 15px;
            padding: 30px 20px;
            text-align: center;
            overflow-y: auto;
            position: relative;
        }

        /* Night Sky Stars */
        .credits-stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 300px;
            pointer-events: none;
            z-index: 0;
        }

        .credits-star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ff00;
            box-shadow: 0 0 3px #00ff00;
            animation: twinkle 2s infinite;
        }

        /* Title Section */
        .credits-game-title {
            position: relative;
            z-index: 1;
            margin: 20px 0 10px 0;
        }

        .title-text {
            font-family: 'Press Start 2P', monospace;
            font-size: 64px;
            color: #00ff00;
            text-shadow:
                4px 4px 0px #008800,
                0 0 20px rgba(0, 255, 0, 0.5);
            letter-spacing: 8px;
            margin-bottom: 10px;
        }

        .title-subtitle {
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: #00aa00;
            letter-spacing: 2px;
        }

        /* NYC Skyline */
        .nyc-skyline {
            position: relative;
            z-index: 1;
            margin: 10px 0 5px 0;
            height: 120px;
            width: 100%;
            max-width: 800px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 2px;
        }

        .road {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 30px;
            background: #002200;
            margin: 0 0 15px 0;
            overflow: visible;
            z-index: 1;
        }

        .road::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background-image: repeating-linear-gradient(
                to right,
                #005500 0px,
                #005500 10px,
                transparent 10px,
                transparent 20px
            );
            transform: translateY(-50%);
        }

        .car {
            position: absolute;
            width: 28px;
            height: 14px;
            background: transparent;
            image-rendering: pixelated;
        }

        .car.top-lane {
            top: 3px;
        }

        .car.bottom-lane {
            bottom: 3px;
        }

        .car.left-to-right {
            animation: driveRight linear;
        }

        .car.right-to-left {
            animation: driveLeft linear;
            transform: scaleX(-1);
        }

        @keyframes driveRight {
            from {
                left: -30px;
            }
            to {
                left: 100%;
            }
        }

        @keyframes driveLeft {
            from {
                right: -30px;
            }
            to {
                right: 100%;
            }
        }

        .building {
            position: relative;
            background: #004d00;
            border: 1px solid #004d00;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 3px;
            gap: 2px;
            flex-wrap: wrap;
        }

        .building-top {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            background: #004d00;
            opacity: 0.8;
        }

        .building-crown {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 8px solid #004d00;
            opacity: 0.7;
        }

        .building-setback {
            position: absolute;
            top: 0;
            background: #003300;
            border: 1px solid #004d00;
        }

        .window {
            transition: opacity 0.8s ease-in-out;
        }

        .window.off {
            opacity: 0.15;
        }

        .credits-company {
            margin: 30px 0 20px 0;
            position: relative;
            z-index: 1;
            display: flex;
            justify-content: center;
        }

        .company-box {
            color: #00ff00;
            font-family: 'Press Start 2P', 'VT323', monospace;
            font-size: 24px;
            padding: 0;
            animation: glowPulse 2s ease-in-out infinite;
            position: relative;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .company-box .asterisk {
            font-size: 16.8px; /* 24px * 0.7 = 30% 감소 */
        }

        .company-box .bracket {
            font-size: 24px;
        }

        .company-box .company-text {
            font-size: 24px;
            letter-spacing: 3px;
        }

        @keyframes glowPulse {
            0%, 100% {
                text-shadow:
                    2px 2px 0px #008800,
                    0 0 10px #00ff00,
                    0 0 20px #00ff00;
            }
            50% {
                text-shadow:
                    2px 2px 0px #008800,
                    0 0 20px #00ff00,
                    0 0 40px #00ff00,
                    0 0 60px #00ff00;
            }
        }

        .credits-cast {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin: 20px 0;
            width: 100%;
            max-width: 900px;
            position: relative;
            z-index: 1;
        }

        .credits-character {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .char-box {
            background: #001100;
            border: 3px solid #00ff00;
            padding: 0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.4);
            width: 180px;
            height: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.3s;
            overflow: hidden;
        }

        .char-box:hover {
            border-color: #00ff00;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.6);
            background: #002200;
        }

        .char-box.drag-over {
            border-color: #ffffff;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.8);
            background: #003300;
        }

        .char-box::after {
            content: 'Click or Drop Image';
            position: absolute;
            bottom: 5px;
            font-size: 10px;
            color: #006600;
            font-family: 'VT323', monospace;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .char-box:hover::after {
            opacity: 1;
        }

        .char-portrait {
            width: 180px;
            height: 180px;
            image-rendering: pixelated;
            object-fit: cover;
        }

        .char-placeholder pre {
            margin: 0;
            color: #00ff00;
            font-family: 'VT323', monospace;
            font-size: 20px;
            line-height: 1.2;
            opacity: 0.6;
        }

        .char-name {
            color: #00ff00;
            font-size: 16px;
            font-family: 'VT323', monospace;
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: 2px 2px 0px #008800;
            cursor: pointer;
            padding: 4px 8px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .char-name:hover {
            border-color: #00ff00;
            background: #002200;
        }

        .char-name.editing {
            background: #003300;
            border-color: #00ff00;
            outline: none;
        }

        .char-role {
            color: #00aa00;
            font-size: 14px;
            font-family: 'NeoDunggeunmo', monospace;
            cursor: pointer;
            padding: 4px 8px;
            border: 2px solid transparent;
            transition: all 0.2s;
            margin-top: -12px;
        }

        .char-role:hover {
            border-color: #00aa00;
            background: #002200;
        }

        .char-role.editing {
            background: #003300;
            border-color: #00aa00;
            outline: none;
        }

        .credits-game-footer {
            color: #00ff00;
            font-size: 18px;
            font-family: 'VT323', monospace;
            line-height: 2;
            margin-top: 20px;
            position: relative;
            z-index: 1;
        }

        .year-correction {
            position: relative;
            display: inline-block;
        }

        .strikethrough {
            text-decoration: line-through;
            color: #00cc00;
            text-decoration-thickness: 1px;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        .corrected-year {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff00;
            font-weight: bold;
        }

        /* Image Crop Modal */
        .crop-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .crop-modal.active {
            display: flex;
        }

        .crop-container {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
        }

        .crop-canvas-container {
            position: relative;
            border: 2px solid #00ff00;
            display: inline-block;
        }

        .crop-preview {
            image-rendering: auto;
        }

        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .crop-selection {
            position: absolute;
            border: 2px solid #00ff00;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            cursor: move;
        }

        .crop-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #00ff00;
            border: 1px solid #000;
        }

        .crop-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
        .crop-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .crop-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }

        .crop-buttons {
            margin-top: 20px;
            text-align: center;
        }

        .crop-button {
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 10px 30px;
            font-family: 'VT323', monospace;
            font-size: 20px;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s;
        }

        .crop-button:hover {
            background: #00ff00;
            color: #000000;
        }

        /* Confirmation Dialog */
        .confirm-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .confirm-dialog.active {
            display: flex;
        }

        .confirm-box {
            background: #000000;
            border: 3px solid #00ff00;
            padding: 30px;
            min-width: 400px;
            box-shadow:
                0 0 0 1px #00ff00,
                0 0 0 4px #000000,
                0 0 0 5px #00ff00;
        }

        .confirm-title {
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 24px;
            color: #00ff00;
            margin-bottom: 20px;
            text-align: center;
        }

        .confirm-message {
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 18px;
            color: #00ff00;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.6;
        }

        .confirm-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .confirm-button {
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 18px;
            padding: 10px 30px;
            background: #000000;
            color: #00ff00;
            border: 2px solid #00ff00;
            cursor: pointer;
            transition: all 0.2s;
        }

        .confirm-button:hover {
            background: #00ff00;
            color: #000000;
        }

        .confirm-button.selected {
            background: #00ff00;
            color: #000000;
        }

        /* ========== CHRISTMAS SPECIAL ========== */

        /* Snow Effect */
        .snow-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9998;
            overflow: hidden;
        }

        .snowflake {
            position: absolute;
            color: #ffffff;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            text-shadow: 0 0 3px #aaddff;
            animation: snowfall linear infinite;
            opacity: 0.8;
        }

        @keyframes snowfall {
            0% {
                transform: translateY(-10px) rotate(0deg);
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
            }
        }

        /* ============================================
           AUTH SCREEN STYLES
           ============================================ */
        .auth-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .auth-screen.active {
            display: flex;
        }

        .auth-container {
            border: 2px solid #00ff00;
            padding: 30px 40px;
            background: #000000;
            box-shadow:
                0 0 0 2px #000000,
                0 0 0 4px #00ff00,
                4px 4px 0 0 #003300;
            position: relative;
            z-index: 1;
            min-width: 320px;
        }

        .auth-title {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: #00ff00;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 0 #003300;
        }

        .auth-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            border: 1px solid #00ff00;
        }

        .auth-tab {
            flex: 1;
            padding: 10px;
            background: #001100;
            color: #00aa00;
            border: none;
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .auth-tab:first-child {
            border-right: 1px solid #00ff00;
        }

        .auth-tab:hover {
            background: #002200;
        }

        .auth-tab.active {
            background: #00ff00;
            color: #000000;
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .auth-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .auth-label {
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 14px;
            color: #00ff00;
        }

        .auth-input {
            background: #001100;
            border: 1px solid #00aa00;
            color: #00ff00;
            padding: 10px 12px;
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 16px;
            outline: none;
            transition: all 0.2s;
        }

        .auth-input:focus {
            border-color: #00ff00;
            box-shadow: 0 0 5px #00ff00;
        }

        .auth-input::placeholder {
            color: #005500;
        }

        .auth-input.error {
            border-color: #ff4444;
            box-shadow: 0 0 5px #ff4444;
        }

        .auth-input.success {
            border-color: #00ff00;
        }

        .nickname-status {
            font-size: 12px;
            height: 16px;
            margin-top: 2px;
        }

        .nickname-status.checking {
            color: #aaaa00;
        }

        .nickname-status.available {
            color: #00ff00;
        }

        .nickname-status.taken {
            color: #ff4444;
        }

        .auth-button {
            margin-top: 10px;
            padding: 12px;
            background: #003300;
            border: 2px solid #00ff00;
            color: #00ff00;
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .auth-button:hover:not(:disabled) {
            background: #00ff00;
            color: #000000;
        }

        .auth-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .auth-error {
            color: #ff4444;
            font-size: 12px;
            text-align: center;
            min-height: 20px;
        }

        .auth-back {
            margin-top: 20px;
            color: #00aa00;
            font-size: 14px;
            cursor: pointer;
            text-align: center;
            font-family: 'NeoDunggeunmo', monospace;
        }

        .auth-back:hover {
            color: #00ff00;
            text-decoration: underline;
        }

        /* User Info in Menu Bar */
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
            padding-right: 10px;
        }

        .user-nickname {
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 14px;
            color: #55ff55;
        }

        .logout-btn {
            color: #00aa00;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 8px;
            border: 1px solid #00aa00;
            background: transparent;
            font-family: 'NeoDunggeunmo', monospace;
            transition: all 0.2s;
        }

        .logout-btn:hover {
            color: #ff4444;
            border-color: #ff4444;
        }

        /* Loading Overlay */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-text {
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 24px;
            color: #00ff00;
            animation: loadingBlink 0.5s infinite;
        }

        @keyframes loadingBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* Today Count Display */
        .today-count {
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 12px;
            color: #00aa00;
            margin-left: 10px;
        }

        .today-count.warning {
            color: #ffaa00;
        }

        .today-count.limit {
            color: #ff4444;
        }

        /* Menu item disabled state */
        .menu-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Christmas Theme Colors */
        body.christmas-theme {
            --xmas-red: #ff0000;
            --xmas-green: #00ff00;
            --xmas-gold: #ffaa00;
            --xmas-white: #ffffff;
        }

        /* Christmas Star Decorations */
        body.christmas-theme .star {
            animation: twinkleChristmas 1s infinite;
        }

        @keyframes twinkleChristmas {
            0%, 100% {
                opacity: 0.3;
                background: #ff0000;
                box-shadow: 0 0 3px #ff0000;
            }
            25% {
                opacity: 1;
                background: #00ff00;
                box-shadow: 0 0 5px #00ff00;
            }
            50% {
                opacity: 0.5;
                background: #ffaa00;
                box-shadow: 0 0 4px #ffaa00;
            }
            75% {
                opacity: 1;
                background: #ffffff;
                box-shadow: 0 0 5px #ffffff;
            }
        }

        /* Christmas Menu Styling */
        body.christmas-theme .menu-bar {
            border-bottom: 1px solid #ff0000;
            background: linear-gradient(90deg, #001100 0%, #110000 50%, #001100 100%);
        }

        body.christmas-theme .status-bar {
            border-top: 1px solid #ff0000;
            background: linear-gradient(90deg, #110000 0%, #001100 50%, #110000 100%);
        }

        /* Christmas Settings Button */
        .xmas-button {
            background: #001100;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 8px 20px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .xmas-button:hover {
            background: #002200;
            box-shadow: 0 0 10px #00ff00;
        }

        .xmas-button.active {
            background: #002200;
            color: #55ff55;
            box-shadow: 0 0 10px #00ff00;
        }

        body.christmas-theme .xmas-button.active {
            background: #220000;
            border-color: #ff0000;
            color: #ff5555;
            box-shadow: 0 0 10px #ff0000;
        }

        /* Easter Egg Modal */
        .easter-egg-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10001;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .easter-egg-modal.show {
            display: flex;
        }

        .easter-egg-content {
            text-align: center;
            animation: easterEggAppear 1s ease-out;
        }

        @keyframes easterEggAppear {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        .easter-egg-tree {
            font-size: 80px;
            margin-bottom: 20px;
            animation: treeSparkle 0.5s ease-in-out infinite;
        }

        @keyframes treeSparkle {
            0%, 100% { filter: drop-shadow(0 0 10px #00ff00); }
            50% { filter: drop-shadow(0 0 20px #ffaa00) drop-shadow(0 0 30px #ff0000); }
        }

        .easter-egg-message {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: #00ff00;
            line-height: 2;
            text-shadow: 0 0 10px #00ff00;
        }

        .easter-egg-message .red { color: #ff0000; text-shadow: 0 0 10px #ff0000; }
        .easter-egg-message .gold { color: #ffaa00; text-shadow: 0 0 10px #ffaa00; }
        .easter-egg-message .white { color: #ffffff; text-shadow: 0 0 10px #ffffff; }

        .easter-egg-close {
            margin-top: 30px;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            color: #888888;
            animation: blink 1s infinite;
        }

        /* Christmas Card Menu - Only show in December */
        .xmas-menu-item {
            display: none;
            color: #ff5555 !important;
        }

        body.christmas-theme .xmas-menu-item {
            display: inline;
        }

        /* Christmas Card Screen */
        .xmas-card-screen {
            padding: 20px;
        }

        .xmas-card-container {
            display: flex;
            gap: 30px;
            height: 100%;
            max-height: calc(100vh - 150px);
        }

        .xmas-card-preview {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #001100;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 20px;
        }

        /* Folder-style Card - Vertical Layout */
        .xmas-card-folder {
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .xmas-card-panel {
            width: 642px;
            height: 360px;
            box-sizing: border-box;
        }

        /* Top Panel: Message Area - DOS Style */
        .xmas-card-top-panel {
            background: #000000;
            border: none;
        }

        /* Bottom Panel: GIF */
        .xmas-card-bottom-panel {
            border: none;
        }

        .xmas-card-gif {
            width: 642px;
            height: 360px;
            display: block;
        }

        .xmas-card-message-area {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 20px 45px;
            box-sizing: border-box;
        }

        .xmas-card-header {
            text-align: center;
            margin-bottom: 10px;
        }

        .xmas-title {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: #ffffff;
            display: block;
            margin-bottom: 3px;
        }

        .xmas-card-subtitle {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #ffffff;
            display: block;
        }

        .xmas-card-tagline {
            font-family: 'Press Start 2P', monospace;
            font-size: 11px;
            color: #ffffff;
            display: block;
            margin-top: 8px;
        }

        .xmas-card-to {
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 20px;
            color: #ffffff;
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .xmas-card-message {
            flex: 1;
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 18px;
            color: #ffffff;
            text-align: left;
            line-height: 1.6;
            word-break: keep-all;
            overflow-y: visible;
        }

        .xmas-card-from {
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 20px;
            color: #ffffff;
            margin-top: 10px;
            text-align: right;
        }

        .xmas-card-year {
            display: none;
        }

        .xmas-card-footer {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #ffffff;
            text-align: center;
            margin-top: 10px;
        }

        .xmas-card-editor {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 350px;
        }

        .xmas-card-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .xmas-card-field label {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #00ff00;
        }

        .xmas-card-field input,
        .xmas-card-field textarea {
            background: #001100;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 16px;
            padding: 10px;
            outline: none;
        }

        .xmas-card-field input:focus,
        .xmas-card-field textarea:focus {
            border-color: #55ff55;
            box-shadow: 0 0 5px #00ff00;
        }

        .xmas-card-field textarea {
            height: 120px;
            resize: none;
        }

        .xmas-card-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .xmas-card-btn {
            background: #002200;
            border: 2px solid #00ff00;
            color: #00ff00;
            font-family: 'VT323', monospace;
            font-size: 16px;
            padding: 8px 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .xmas-card-btn:hover {
            background: #004400;
            box-shadow: 0 0 10px #00ff00;
        }

        .xmas-card-list-title {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #ffaa00;
            margin-top: 10px;
        }

        .xmas-card-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #004400;
            background: #000800;
            padding: 10px;
            min-height: 100px;
        }

        .xmas-card-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #003300;
            cursor: pointer;
            transition: background 0.2s;
        }

        .xmas-card-list-item:hover {
            background: #002200;
        }

        .xmas-card-list-item-info {
            font-family: 'NeoDunggeunmo', monospace;
            font-size: 14px;
            color: #00ff00;
        }

        .xmas-card-list-item-delete {
            color: #ff5555;
            cursor: pointer;
            font-size: 16px;
        }

        .xmas-card-list-item-delete:hover {
            color: #ff0000;
        }
    </style>
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Mermaid.js for diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <!-- html2canvas for card download -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <!-- gif.js for GIF animation export -->
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.min.js"></script>
    <!-- omggif for GIF frame extraction (browser-compatible) -->
    <script src="https://cdn.jsdelivr.net/npm/omggif@1.0.10/omggif.js"></script>
</head>
<body>
    <!-- Snow Container -->
    <div class="snow-container" id="snowContainer"></div>

    <!-- Easter Egg Modal -->
    <div class="easter-egg-modal" id="easterEggModal">
        <div class="easter-egg-content">
            <div class="easter-egg-tree">🎄</div>
            <div class="easter-egg-message" id="easterEggMessage">
                <span class="red">M</span><span class="gold">E</span><span class="green">R</span><span class="red">R</span><span class="gold">Y</span>
                <span class="white">CHRISTMAS!</span><br><br>
                <span style="font-size: 12px;">🎅 Santa says: Keep writing!</span><br>
                <span style="font-size: 10px; color: #888888;">- From POPUP-STUDIO with ❤️ -</span>
            </div>
            <div class="easter-egg-close">Press any key to close</div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-text">Loading...</div>
    </div>

    <div class="screen">
        <!-- Title Screen -->
        <div class="main-container title-screen" id="titleScreen">
            <div class="stars" id="stars"></div>
            <div class="logo">DOOGIE</div>
            <div class="main-menu">
                <div class="menu-item" data-action="write">일기쓰기</div>
                <div class="menu-item" data-action="list">나의 일기장</div>
                <div class="menu-item" data-action="credits">디스켓</div>
                <div class="menu-item" data-action="auth" id="authMenuItem">로그인</div>
            </div>
        </div>

        <!-- Auth Screen -->
        <div class="main-container auth-screen" id="authScreen">
            <div class="stars" id="authStars"></div>
            <div class="auth-container">
                <div class="auth-title">DOOGIE</div>
                <div class="auth-tabs">
                    <button class="auth-tab active" data-tab="login">로그인</button>
                    <button class="auth-tab" data-tab="signup">회원가입</button>
                </div>
                <form class="auth-form" id="authForm">
                    <div class="auth-field">
                        <label class="auth-label">닉네임</label>
                        <input type="text" class="auth-input" id="authNickname"
                               placeholder="2-12자" minlength="2" maxlength="12" required>
                        <div class="nickname-status" id="nicknameStatus"></div>
                    </div>
                    <div class="auth-field">
                        <label class="auth-label">PIN (숫자 4자리)</label>
                        <input type="password" class="auth-input" id="authPin"
                               placeholder="****" pattern="[0-9]{4}" maxlength="4"
                               inputmode="numeric" required>
                    </div>
                    <div class="auth-error" id="authError"></div>
                    <button type="submit" class="auth-button" id="authSubmitBtn">로그인</button>
                </form>
                <div class="auth-back" id="authBack">← 돌아가기</div>
            </div>
        </div>

        <!-- App Container -->
        <div class="app-container" id="appContainer">
            <div class="diary-container">
            <div class="menu-bar">
                <span class="menu-item-top" data-action="home">Home</span>
                <span class="menu-item-top" data-action="new">New</span>
                <span class="menu-item-top" data-action="save">Save</span>
                <div class="menu-item-wrapper">
                    <span class="menu-item-top" data-action="picture">Picture</span>
                    <div class="picture-menu-panel" id="pictureMenuPanel">
                        <!-- Picture menu will be populated here -->
                    </div>
                </div>
                <div class="menu-item-wrapper">
                    <span class="menu-item-top" data-action="list">List</span>
                    <div class="diary-list-panel" id="diaryListPanel">
                        <!-- Diary list will be populated here -->
                    </div>
                </div>
                <span class="menu-item-top" data-action="help">Help</span>
                <span class="menu-item-top xmas-menu-item" data-action="xmascard" id="xmasCardMenu">🎄 Card</span>
                <span class="menu-item-top" data-action="fullscreen" id="fullscreenBtn">Fullscreen</span>
                <span class="today-count" id="todayCount"></span>
                <div class="mode-toggle-container">
                    <span class="mode-toggle-label" id="modeLabel">DIARY</span>
                    <button class="mode-toggle-btn" id="modeToggleBtn" title="Toggle Diary/Markdown Mode">
                        <span class="mode-toggle-indicator" id="modeIndicator"></span>
                    </button>
                </div>
                <div class="user-info" id="userInfo">
                    <span class="user-nickname" id="userNickname"></span>
                    <button class="logout-btn" id="logoutBtn">Logout</button>
                </div>
            </div>

            <div class="content mode-view" id="contentView">
                <div class="date-header" id="dateHeader"></div>
                <!-- Diary Mode Editor -->
                <div class="editor-wrapper" id="diaryEditorWrapper">
                    <div class="editor-section">
                        <textarea class="editor" id="editor"></textarea>
                        <div class="cursor" id="cursor"></div>
                    </div>
                    <div class="images-section" id="imagesSection">
                        <div class="images-container" id="imagesContainer"></div>
                    </div>
                </div>
                <!-- Markdown Mode Editor -->
                <div class="markdown-wrapper" id="markdownEditorWrapper" style="display: none;">
                    <div class="markdown-editor-section">
                        <div class="markdown-toolbar" id="markdownToolbar">
                            <button class="md-tool-btn" data-action="heading" title="Heading (Ctrl+H)">#</button>
                            <button class="md-tool-btn" data-action="bold" title="Bold (Ctrl+B)">B</button>
                            <button class="md-tool-btn" data-action="italic" title="Italic (Ctrl+I)">I</button>
                            <button class="md-tool-btn" data-action="code" title="Code (Ctrl+`)">&lt;/&gt;</button>
                            <button class="md-tool-btn" data-action="link" title="Link (Ctrl+K)">🔗</button>
                            <button class="md-tool-btn" data-action="list" title="List">•</button>
                            <button class="md-tool-btn" data-action="quote" title="Quote">❝</button>
                            <button class="md-tool-btn" data-action="table" title="Table">▦</button>
                            <button class="md-tool-btn" data-action="mermaid" title="Mermaid Diagram">◈</button>
                            <span class="md-toolbar-separator"></span>
                            <button class="md-tool-btn md-preview-btn" data-action="preview" title="Toggle Preview (Ctrl+P)" id="previewToggleBtn">👁 Preview</button>
                        </div>
                        <div class="markdown-edit-area">
                            <textarea class="markdown-editor" id="markdownEditor" placeholder="Write in Markdown..."></textarea>
                            <div class="markdown-preview" id="markdownPreview" style="display: none;"></div>
                        </div>
                    </div>
                </div>
                <input type="file" id="fileInput" accept="image/*" style="display: none;" multiple>
                <input type="file" id="importInput" accept=".json,application/json" style="display: none;">
            </div>

            <div class="content mode-list entry-list" id="entryList">
                <!-- Entry list will be populated here -->
            </div>

            <div class="content mode-calendar calendar-container" id="calendarContainer">
                <div class="calendar-left">
                    <div class="calendar-header">
                        <button class="calendar-nav-btn" id="prevMonthBtn">◀</button>
                        <div class="calendar-title" id="calendarTitle">JANUARY 2025</div>
                        <button class="calendar-nav-btn" id="nextMonthBtn">▶</button>
                    </div>
                    <div class="calendar-grid" id="calendarGrid">
                        <!-- Calendar will be populated here -->
                    </div>
                </div>
                <div class="calendar-right">
                    <div class="calendar-list-section">
                        <div class="calendar-list-title">Diary Entries</div>
                        <div id="calendarEntryList">
                            <!-- Entry list will be populated here -->
                        </div>
                    </div>
                    <div class="list-footer">
                        <button class="settings-link-button" id="settingsLinkButtonCalendar">⚙ Settings</button>
                    </div>
                </div>
            </div>

            <div class="content mode-help help-screen" id="helpScreen">
                <div class="help-title">═══ HELP SCREEN ═══</div>
                <div class="help-item"><span class="shortcut">F1</span> - 도움말 보기/닫기</div>
                <div class="help-item"><span class="shortcut">F2</span> - 현재 일기 저장</div>
                <div class="help-item"><span class="shortcut">F3</span> - 일기 목록 보기</div>
                <div class="help-item"><span class="shortcut">F4</span> - 새 일기 작성</div>
                <div class="help-item"><span class="shortcut">ESC</span> - 목록/도움말에서 나가기</div>
                <div style="margin-top: 20px; color: #55ff55;">═══ MARKDOWN MODE ═══</div>
                <div class="help-item"><span class="shortcut">Ctrl+M</span> - Diary/Markdown 모드 전환</div>
                <div class="help-item"><span class="shortcut">Ctrl+P</span> - 마크다운 미리보기 토글</div>
                <div style="margin-top: 30px; color: #aaaaaa;">
                    ┌─────────────────────────────────────────────┐<br>
                    │ 모든 일기는 브라우저에 자동 저장됩니다.      │<br>
                    │ F2를 눌러 수동으로 저장할 수도 있습니다.     │<br>
                    │                                             │<br>
                    │ <span style="color: #55ff55;">Markdown 모드</span>: 구조화된 문서 작성용     │<br>
                    │ Mermaid 다이어그램도 지원됩니다!            │<br>
                    └─────────────────────────────────────────────┘
                </div>
            </div>

            <div class="content mode-settings settings-screen" id="settingsScreen">
                <div class="settings-title">═══ SETTINGS ═══</div>
                <div class="settings-section">
                    <div class="setting-item">
                        <div class="setting-label">Language / 언어</div>
                        <div class="setting-control">
                            <button class="lang-button active" data-lang="ko">한국어</button>
                            <button class="lang-button" data-lang="en">English</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-label">🎄 Christmas Mode</div>
                        <div class="setting-control">
                            <button class="xmas-button" id="xmasToggleBtn" data-xmas="off">OFF</button>
                        </div>
                    </div>
                    <div class="setting-item xmas-bgm-setting" id="xmasBgmSetting" style="display: none;">
                        <div class="setting-label">🎵 Christmas BGM</div>
                        <div class="setting-control">
                            <button class="xmas-button" id="bgmToggleBtn" data-bgm="off">OFF</button>
                        </div>
                    </div>
                </div>
                <div class="settings-footer">Press ESC to Return</div>
            </div>

            <div class="content mode-credits credits-screen" id="creditsScreen">
                <!-- Night Sky with Twinkling Stars -->
                <div class="credits-stars" id="creditsStars"></div>

                <!-- Game Title -->
                <div class="credits-game-title">
                    <div class="title-text">DOOGIE</div>
                    <div class="title-subtitle">An Interactive Diary Experience</div>
                </div>

                <!-- NYC Skyline -->
                <div class="nyc-skyline" id="nycSkyline"></div>

                <!-- Road with Cars -->
                <div class="road" id="road"></div>

                <div class="credits-company">
                    <div class="company-box">
                        <span class="asterisk">**</span>
                        <span class="bracket">&lt;&lt;</span>
                        <span class="company-text">POPUP STUDIO</span>
                        <span class="bracket">&gt;&gt;</span>
                        <span class="asterisk">**</span>
                    </div>
                </div>

                <div class="credits-cast">
                    <div class="credits-character">
                        <div class="char-box">
                            <canvas class="char-portrait" id="char1Canvas" width="180" height="180"></canvas>
                        </div>
                        <div class="char-name">KOYU THE CREATOR</div>
                        <div class="char-role">POPUP-STUDIO</div>
                    </div>

                    <div class="credits-character">
                        <div class="char-box">
                            <canvas class="char-portrait" id="char2Canvas" width="180" height="180"></canvas>
                        </div>
                        <div class="char-name">CLAUDE THE WIZARD</div>
                        <div class="char-role">Anthropic AI</div>
                    </div>

                    <div class="credits-character">
                        <div class="char-box">
                            <canvas class="char-portrait" id="char3Canvas" width="180" height="180"></canvas>
                        </div>
                        <div class="char-name">CHARACTER 3</div>
                        <div class="char-role">Role TBD</div>
                    </div>

                    <div class="credits-character">
                        <div class="char-box">
                            <canvas class="char-portrait" id="char4Canvas" width="180" height="180"></canvas>
                        </div>
                        <div class="char-name">CHARACTER 4</div>
                        <div class="char-role">Role TBD</div>
                    </div>

                    <div class="credits-character">
                        <div class="char-box">
                            <canvas class="char-portrait" id="char5Canvas" width="180" height="180"></canvas>
                        </div>
                        <div class="char-name">CHARACTER 5</div>
                        <div class="char-role">Role TBD</div>
                    </div>

                    <div class="credits-character">
                        <div class="char-box">
                            <canvas class="char-portrait" id="char6Canvas" width="180" height="180"></canvas>
                        </div>
                        <div class="char-name">CHARACTER 6</div>
                        <div class="char-role">Role TBD</div>
                    </div>
                </div>

                <div class="credits-game-footer">
                    ✦ ✦ ✦  Press ESC to Continue  ✦ ✦ ✦<br>
                    <br>
                    © <span class="year-correction"><span class="strikethrough">1985</span><span class="corrected-year">2025</span></span> POPUP-STUDIO - Made with 💚 in DOS Era
                </div>
            </div>

            <!-- Christmas Card Screen -->
            <div class="content mode-xmascard xmas-card-screen" id="xmasCardScreen">
                <div class="xmas-card-container">
                    <div class="xmas-card-preview" id="xmasCardPreview">
                        <div class="xmas-card-folder">
                            <!-- Top Panel: Message Area - DOS Style -->
                            <div class="xmas-card-panel xmas-card-top-panel">
                                <div class="xmas-card-message-area">
                                    <div class="xmas-card-header">
                                        <span class="xmas-title">Merry Christmas</span>
                                        <span class="xmas-card-subtitle">to</span>
                                        <span class="xmas-card-subtitle">My Special Someone</span>
                                        <span class="xmas-card-tagline">"Commit to Joy, Push the Vibes."</span>
                                    </div>
                                    <div class="xmas-card-to">Dear <span id="cardToPreview">_____</span>,</div>
                                    <div class="xmas-card-message" id="cardMessagePreview">
                                        Write your message...
                                    </div>
                                    <div class="xmas-card-from">- <span id="cardFromPreview">_____</span></div>
                                    <div class="xmas-card-footer">press ENTER to continue</div>
                                </div>
                            </div>
                            <!-- Bottom Panel: GIF -->
                            <div class="xmas-card-panel xmas-card-bottom-panel">
                                <img src="card_dos.gif" alt="Christmas Card" class="xmas-card-gif">
                            </div>
                        </div>
                    </div>
                    <div class="xmas-card-editor">
                        <div class="xmas-card-field">
                            <label>To (받는 사람)</label>
                            <input type="text" id="cardToInput" placeholder="친구 이름" maxlength="20">
                        </div>
                        <div class="xmas-card-field">
                            <label>Message (메시지)</label>
                            <textarea id="cardMessageInput" placeholder="따뜻한 마음을 전해보세요..." maxlength="300"></textarea>
                        </div>
                        <div class="xmas-card-field">
                            <label>From (보내는 사람)</label>
                            <input type="text" id="cardFromInput" placeholder="내 이름" maxlength="20">
                        </div>
                        <div class="xmas-card-actions">
                            <button class="xmas-card-btn" id="saveCardBtn">💾 Save Card</button>
                            <button class="xmas-card-btn" id="downloadCardBtn">📥 Download</button>
                            <button class="xmas-card-btn" id="newCardBtn">🆕 New</button>
                        </div>
                        <div class="xmas-card-list-title">📜 Saved Cards</div>
                        <div class="xmas-card-list" id="xmasCardList">
                            <!-- Saved cards will be listed here -->
                        </div>
                    </div>
                </div>
            </div>

            <div class="status-bar">
                <div id="statusLeft">Ready</div>
                <div id="statusRight">
                    <span id="charCount">0 chars</span> |
                    <span id="entryCount">0 entries</span>
                </div>
            </div>
            </div>
        </div>
    </div>

    <!-- Image Modal -->
    <div class="image-modal" id="imageModal">
        <div class="image-modal-close" id="modalClose">X</div>
        <img id="modalImage" src="" alt="">
    </div>

    <!-- Crop Modal -->
    <div class="crop-modal" id="cropModal">
        <div class="crop-container">
            <div class="crop-canvas-container">
                <img class="crop-preview" id="cropPreview" src="" alt="">
                <div class="crop-selection" id="cropSelection">
                    <div class="crop-handle nw"></div>
                    <div class="crop-handle ne"></div>
                    <div class="crop-handle sw"></div>
                    <div class="crop-handle se"></div>
                </div>
            </div>
            <div class="crop-buttons">
                <button class="crop-button" id="cropConfirm">CROP & APPLY</button>
                <button class="crop-button" id="cropCancel">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Confirmation Dialog -->
    <div class="confirm-dialog" id="confirmDialog">
        <div class="confirm-box">
            <div class="confirm-title">┌─ 확인 ─┐</div>
            <div class="confirm-message" id="confirmMessage">저장하지 않은 내용이 있습니다.<br>저장하시겠습니까?</div>
            <div class="confirm-buttons">
                <button class="confirm-button" id="confirmYes">Yes</button>
                <button class="confirm-button" id="confirmNo">No</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // App Configuration
        // ============================================
        // Set to false to use local-only mode (IndexedDB only, no server)
        // Server mode enabled - using https://api-enduser.bkend.ai
        const USE_SERVER_MODE = true;

        // ============================================
        // Bkend API Client Class
        // ============================================
        class BkendAPI {
            constructor() {
                this.baseUrl = '/api';
                this.projectId = 'xmw50no31alhxozn08ex';
                this.environment = 'dev';
                this.accessToken = localStorage.getItem('doogie_access_token') || null;
                this.currentUser = null;
            }

            // Helper to make API requests
            async request(endpoint, options = {}) {
                // Check online status
                if (!navigator.onLine) {
                    throw new Error('OFFLINE');
                }

                const headers = {
                    'Content-Type': 'application/json',
                    'X-Project-Id': this.projectId,
                    'X-Environment': this.environment,
                    ...options.headers
                };

                if (this.accessToken) {
                    headers['Authorization'] = `Bearer ${this.accessToken}`;
                }

                let response;
                try {
                    response = await fetch(`${this.baseUrl}${endpoint}`, {
                        ...options,
                        headers
                    });
                } catch (fetchError) {
                    // Network error (CORS, connection failed, etc.)
                    throw new Error('NETWORK_ERROR');
                }

                // Handle 401 Unauthorized - token expired
                if (response.status === 401) {
                    this.logout();
                    throw new Error('SESSION_EXPIRED');
                }

                const data = await response.json();

                if (!response.ok) {
                    // Bkend API error structure: { success: false, error: { message: "..." } }
                    // or { message: "..." } or { error: "..." }
                    let errorMessage = 'API request failed';
                    if (data.error && typeof data.error === 'object' && data.error.message) {
                        errorMessage = data.error.message;
                    } else if (data.error && typeof data.error === 'string') {
                        errorMessage = data.error;
                    } else if (data.message && typeof data.message === 'string') {
                        errorMessage = data.message;
                    }
                    throw new Error(errorMessage);
                }

                return data;
            }

            // Convert nickname to email format
            nicknameToEmail(nickname) {
                return `${nickname}@doogie.app`;
            }

            // Extract nickname from email
            emailToNickname(email) {
                return email.replace('@doogie.app', '');
            }

            // Convert 4-digit PIN to password format (meets Bkend password policy)
            // Requirements: min 8 chars, uppercase, lowercase, number, special char
            pinToPassword(pin) {
                return `Doo@gie${pin}#Pwd`;
            }

            // Check if user is logged in
            isLoggedIn() {
                return !!this.accessToken && !!this.currentUser;
            }

            // Get current user nickname
            getNickname() {
                if (this.currentUser && this.currentUser.email) {
                    return this.emailToNickname(this.currentUser.email);
                }
                return null;
            }

            // Sign up new user
            async signup(nickname, pin) {
                const email = this.nicknameToEmail(nickname);
                const password = this.pinToPassword(pin);
                const data = await this.request('/auth/signup/password', {
                    method: 'POST',
                    body: JSON.stringify({
                        email: email,
                        password: password,
                        name: nickname,
                        callbackUrl: window.location.origin
                    })
                });

                // Response uses access_token (snake_case)
                if (data.data && data.data.access_token) {
                    this.accessToken = data.data.access_token;
                    localStorage.setItem('doogie_access_token', this.accessToken);
                    await this.fetchCurrentUser();
                }

                return data;
            }

            // Sign in existing user
            async signin(nickname, pin) {
                const email = this.nicknameToEmail(nickname);
                const password = this.pinToPassword(pin);
                const data = await this.request('/auth/signin/password', {
                    method: 'POST',
                    body: JSON.stringify({
                        email: email,
                        password: password,
                        callbackUrl: window.location.origin
                    })
                });

                // Response uses access_token (snake_case)
                if (data.data && data.data.access_token) {
                    this.accessToken = data.data.access_token;
                    localStorage.setItem('doogie_access_token', this.accessToken);
                    await this.fetchCurrentUser();
                }

                return data;
            }

            // Get current user info
            async fetchCurrentUser() {
                try {
                    const data = await this.request('/auth/me');
                    this.currentUser = data.data;
                    return this.currentUser;
                } catch (error) {
                    this.logout();
                    throw error;
                }
            }

            // Check if nickname is available (try to sign in with wrong password)
            // Note: Real-time nickname check removed due to API limitations
            // Duplicate check happens at signup time via server response
            async checkNicknameAvailable(nickname) {
                // Always return true - actual check happens during signup
                return true;
            }

            // Logout
            logout() {
                this.accessToken = null;
                this.currentUser = null;
                localStorage.removeItem('doogie_access_token');
            }

            // ============================================
            // Entry (Diary) CRUD Operations
            // ============================================

            // Get all entries for current user
            async getAllEntries() {
                const data = await this.request('/data/entries?limit=1000&sortBy=dateKey&sortDirection=desc');
                return data.data.items || [];
            }

            // Get entries for a specific date
            async getEntriesByDate(dateKey) {
                const filter = encodeURIComponent(JSON.stringify({ dateKey }));
                const data = await this.request(`/data/entries?andFilters=${filter}&sortBy=entryNumber&sortDirection=asc`);
                return data.data.items || [];
            }

            // Get entries for a specific month (for calendar)
            async getEntriesByMonth(year, month) {
                const monthStr = String(month + 1).padStart(2, '0');
                const pattern = `^${year}-${monthStr}`;
                const filter = encodeURIComponent(JSON.stringify({ dateKey: { $regex: pattern } }));
                const data = await this.request(`/data/entries?andFilters=${filter}&limit=1000&sortBy=dateKey&sortDirection=desc`);
                return data.data.items || [];
            }

            // Get count of entries for today
            async getTodayCount() {
                const today = new Date().toISOString().split('T')[0];
                const entries = await this.getEntriesByDate(today);
                return entries.length;
            }

            // Create new entry
            async createEntry(dateKey, entryNumber, type, text, images = []) {
                const data = await this.request('/data/entries', {
                    method: 'POST',
                    body: JSON.stringify({
                        dateKey,
                        entryNumber,
                        type,
                        text,
                        images
                    })
                });
                return data.data;
            }

            // Update existing entry
            async updateEntry(entryId, updates) {
                const data = await this.request(`/data/entries/${entryId}`, {
                    method: 'PUT',
                    body: JSON.stringify(updates)
                });
                return data.data;
            }

            // Delete entry
            async deleteEntry(entryId) {
                await this.request(`/data/entries/${entryId}`, {
                    method: 'DELETE'
                });
            }

            // Get next entry number for a date
            async getNextEntryNumber(dateKey) {
                const entries = await this.getEntriesByDate(dateKey);
                if (entries.length === 0) return 1;
                const maxNumber = Math.max(...entries.map(e => e.entryNumber || 1));
                return maxNumber + 1;
            }

            // Check if can create more entries today (100 limit)
            async canCreateEntryToday() {
                const count = await this.getTodayCount();
                return count < 100;
            }
        }

        // Initialize Bkend API client
        const bkendAPI = new BkendAPI();

        // ============================================
        // IndexedDB Storage Class (for settings only)
        // ============================================
        class DiaryDB {
            constructor(dbName = 'doogie-diary-db', version = 1) {
                this.dbName = dbName;
                this.version = version;
                this.db = null;
                this.isReady = false;
                this.readyPromise = this.init();
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);

                    request.onerror = () => {
                        console.error('IndexedDB open error:', request.error);
                        reject(request.error);
                    };

                    request.onsuccess = () => {
                        this.db = request.result;
                        this.isReady = true;
                        console.log('IndexedDB initialized successfully');
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        // Create entries store
                        if (!db.objectStoreNames.contains('entries')) {
                            const entriesStore = db.createObjectStore('entries', { keyPath: 'key' });
                            entriesStore.createIndex('date', 'date', { unique: false });
                        }

                        // Create settings store
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }

                        // Create characters store
                        if (!db.objectStoreNames.contains('characters')) {
                            db.createObjectStore('characters', { keyPath: 'key' });
                        }

                        console.log('IndexedDB schema created/upgraded');
                    };
                });
            }

            async waitForReady() {
                if (this.isReady) return this.db;
                return this.readyPromise;
            }

            async getAllEntries() {
                await this.waitForReady();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['entries'], 'readonly');
                    const store = transaction.objectStore('entries');
                    const request = store.getAll();

                    request.onsuccess = () => {
                        const entries = {};
                        request.result.forEach(item => {
                            entries[item.key] = item.data;
                        });
                        resolve(entries);
                    };
                    request.onerror = () => reject(request.error);
                });
            }

            async saveEntry(key, data) {
                await this.waitForReady();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['entries'], 'readwrite');
                    const store = transaction.objectStore('entries');
                    const date = key.split('-#')[0]; // Extract date from key like "2024-01-15-#1"
                    const request = store.put({ key, date, data });

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async deleteEntry(key) {
                await this.waitForReady();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['entries'], 'readwrite');
                    const store = transaction.objectStore('entries');
                    const request = store.delete(key);

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async saveAllEntries(entries) {
                await this.waitForReady();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['entries'], 'readwrite');
                    const store = transaction.objectStore('entries');

                    // Clear existing and add all
                    store.clear();

                    for (const [key, data] of Object.entries(entries)) {
                        const date = key.split('-#')[0];
                        store.put({ key, date, data });
                    }

                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                });
            }

            async getSetting(key) {
                await this.waitForReady();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['settings'], 'readonly');
                    const store = transaction.objectStore('settings');
                    const request = store.get(key);

                    request.onsuccess = () => resolve(request.result?.value);
                    request.onerror = () => reject(request.error);
                });
            }

            async saveSetting(key, value) {
                await this.waitForReady();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['settings'], 'readwrite');
                    const store = transaction.objectStore('settings');
                    const request = store.put({ key, value });

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async getCharacters() {
                await this.waitForReady();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['characters'], 'readonly');
                    const store = transaction.objectStore('characters');
                    const request = store.get('characters');

                    request.onsuccess = () => resolve(request.result?.value || []);
                    request.onerror = () => reject(request.error);
                });
            }

            async saveCharacters(characters) {
                await this.waitForReady();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['characters'], 'readwrite');
                    const store = transaction.objectStore('characters');
                    const request = store.put({ key: 'characters', value: characters });

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            // Migrate from localStorage to IndexedDB
            async migrateFromLocalStorage() {
                await this.waitForReady();

                // Migrate diary entries
                const savedDiary = localStorage.getItem('doogie-diary');
                if (savedDiary) {
                    try {
                        const entries = JSON.parse(savedDiary);
                        await this.saveAllEntries(entries);
                        console.log('Migrated diary entries from localStorage');
                        // Keep localStorage as backup for now, will be cleared after successful migration
                    } catch (e) {
                        console.error('Failed to migrate diary entries:', e);
                    }
                }

                // Migrate characters
                const savedChars = localStorage.getItem('doogie-characters');
                if (savedChars) {
                    try {
                        const characters = JSON.parse(savedChars);
                        await this.saveCharacters(characters);
                        console.log('Migrated characters from localStorage');
                    } catch (e) {
                        console.error('Failed to migrate characters:', e);
                    }
                }

                // Migrate language setting
                const savedLang = localStorage.getItem('doogie-language');
                if (savedLang) {
                    await this.saveSetting('language', savedLang);
                    console.log('Migrated language setting from localStorage');
                }

                // Clear localStorage after successful migration
                localStorage.removeItem('doogie-diary');
                localStorage.removeItem('doogie-characters');
                localStorage.removeItem('doogie-language');
                console.log('Cleared localStorage after migration');
            }
        }

        // Initialize IndexedDB
        const diaryDB = new DiaryDB();

        // State
        let currentMode = 'title'; // title, view, list, help
        let currentDate = new Date().toISOString().split('T')[0];
        let currentEntryNumber = 1; // For multiple entries on same date
        let entries = {};
        let autoSaveTimeout = null;
        let selectedMenuItem = 0;
        let hasUnsavedChanges = false;
        let lastSavedContent = '';

        // Markdown Mode State
        let editorMode = 'diary'; // 'diary' or 'markdown'
        let markdownPreviewVisible = false;
        let lastSavedMarkdownContent = '';

        // Auth State
        let isAuthMode = 'login'; // 'login' or 'signup'
        let nicknameCheckTimeout = null;
        let currentEntryId = null; // Bkend entry ID for updates

        // DOM Elements
        const titleScreen = document.getElementById('titleScreen');
        const authScreen = document.getElementById('authScreen');
        const appContainer = document.getElementById('appContainer');
        const editor = document.getElementById('editor');
        const dateHeader = document.getElementById('dateHeader');
        const entryList = document.getElementById('entryList');
        const statusLeft = document.getElementById('statusLeft');
        const statusRight = document.getElementById('statusRight');
        const charCount = document.getElementById('charCount');
        const entryCount = document.getElementById('entryCount');
        const contentView = document.querySelector('.mode-view');
        const contentList = document.querySelector('.mode-list');
        const helpScreen = document.querySelector('.mode-help');
        const settingsScreen = document.querySelector('.mode-settings');
        const creditsScreen = document.querySelector('.mode-credits');
        const menuItems = document.querySelectorAll('.menu-item');
        const topMenuItems = document.querySelectorAll('.menu-item-top');
        const diaryListPanel = document.getElementById('diaryListPanel');
        const pictureMenuPanel = document.getElementById('pictureMenuPanel');
        const cursor = document.getElementById('cursor');
        const fileInput = document.getElementById('fileInput');
        const imagesContainer = document.getElementById('imagesContainer');
        const imagesSection = document.getElementById('imagesSection');
        const imageModal = document.getElementById('imageModal');
        const modalImage = document.getElementById('modalImage');
        const modalClose = document.getElementById('modalClose');
        const confirmDialog = document.getElementById('confirmDialog');
        const confirmYes = document.getElementById('confirmYes');
        const confirmNo = document.getElementById('confirmNo');
        const starsContainer = document.getElementById('stars');
        const creditsStars = document.getElementById('creditsStars');
        const importInput = document.getElementById('importInput');
        const calendarContainer = document.getElementById('calendarContainer');
        const calendarGrid = document.getElementById('calendarGrid');
        const calendarTitle = document.getElementById('calendarTitle');
        const prevMonthBtn = document.getElementById('prevMonthBtn');
        const nextMonthBtn = document.getElementById('nextMonthBtn');
        const calendarEntryList = document.getElementById('calendarEntryList');
        const settingsLinkButtonCalendar = document.getElementById('settingsLinkButtonCalendar');

        // Markdown Mode DOM Elements
        const modeToggleBtn = document.getElementById('modeToggleBtn');
        const modeLabel = document.getElementById('modeLabel');
        const modeIndicator = document.getElementById('modeIndicator');
        const diaryEditorWrapper = document.getElementById('diaryEditorWrapper');
        const markdownEditorWrapper = document.getElementById('markdownEditorWrapper');
        const markdownEditor = document.getElementById('markdownEditor');
        const markdownPreview = document.getElementById('markdownPreview');
        const markdownToolbar = document.getElementById('markdownToolbar');
        const previewToggleBtn = document.getElementById('previewToggleBtn');

        // Auth DOM Elements
        const authForm = document.getElementById('authForm');
        const authNickname = document.getElementById('authNickname');
        const authPin = document.getElementById('authPin');
        const authError = document.getElementById('authError');
        const authSubmitBtn = document.getElementById('authSubmitBtn');
        const authBack = document.getElementById('authBack');
        const authMenuItem = document.getElementById('authMenuItem');
        const nicknameStatus = document.getElementById('nicknameStatus');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const userInfo = document.getElementById('userInfo');
        const userNickname = document.getElementById('userNickname');
        const logoutBtn = document.getElementById('logoutBtn');
        const todayCount = document.getElementById('todayCount');

        // Calendar state
        let currentCalendarYear = new Date().getFullYear();
        let currentCalendarMonth = new Date().getMonth(); // 0-11

        // Canvas for text measurement
        let measureCanvas = null;
        let measureCtx = null;

        // Create twinkling stars
        function createStars() {
            const starCount = 50; // 별의 개수
            starsContainer.innerHTML = '';

            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';

                // 랜덤 위치
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';

                // 랜덤 애니메이션 딜레이 (깜빡임 타이밍을 다르게)
                star.style.animationDelay = Math.random() * 3 + 's';

                // 랜덤 애니메이션 지속시간 (2~4초 사이)
                star.style.animationDuration = (2 + Math.random() * 2) + 's';

                starsContainer.appendChild(star);
            }
        }

        // Create NYC Skyline with buildings
        function createNYCSkyline() {
            const skyline = document.getElementById('nycSkyline');
            if (!skyline) return;

            skyline.innerHTML = '';

            // More diverse building configurations with different styles and window types
            const buildings = [
                { width: 25, height: 55, windowsPerRow: 2, rows: 5, style: 'antenna', windowType: 'small' },
                { width: 42, height: 95, windowsPerRow: 3, rows: 9, style: 'crown', windowType: 'wide' },
                { width: 30, height: 70, windowsPerRow: 2, rows: 7, style: 'flat', windowType: 'square' },
                { width: 55, height: 110, windowsPerRow: 4, rows: 11, style: 'antenna', windowType: 'tall' },
                { width: 35, height: 80, windowsPerRow: 2, rows: 8, style: 'flat', windowType: 'small' },
                { width: 48, height: 100, windowsPerRow: 3, rows: 10, style: 'crown', windowType: 'square' },
                { width: 28, height: 60, windowsPerRow: 2, rows: 6, style: 'flat', windowType: 'wide' },
                { width: 40, height: 88, windowsPerRow: 3, rows: 8, style: 'antenna', windowType: 'tall' },
                { width: 32, height: 75, windowsPerRow: 2, rows: 7, style: 'flat', windowType: 'small' },
                { width: 50, height: 105, windowsPerRow: 4, rows: 10, style: 'crown', windowType: 'square' },
                { width: 38, height: 68, windowsPerRow: 3, rows: 6, style: 'flat', windowType: 'wide' },
                { width: 45, height: 92, windowsPerRow: 3, rows: 9, style: 'antenna', windowType: 'tall' },
                { width: 33, height: 78, windowsPerRow: 2, rows: 8, style: 'flat', windowType: 'small' },
                { width: 52, height: 98, windowsPerRow: 4, rows: 9, style: 'crown', windowType: 'square' },
                { width: 36, height: 65, windowsPerRow: 2, rows: 6, style: 'flat', windowType: 'wide' }
            ];

            buildings.forEach(config => {
                const building = document.createElement('div');
                building.className = 'building';
                building.style.width = config.width + 'px';
                building.style.height = config.height + 'px';

                // Add rooftop decoration based on style
                if (config.style === 'antenna') {
                    const antenna = document.createElement('div');
                    antenna.className = 'building-top';
                    const antennaHeight = 10 + Math.random() * 15;
                    antenna.style.height = antennaHeight + 'px';
                    antenna.style.top = -antennaHeight + 'px';
                    building.appendChild(antenna);
                } else if (config.style === 'crown') {
                    const crown = document.createElement('div');
                    crown.className = 'building-crown';
                    building.appendChild(crown);
                }

                // Create windows with different sizes based on type
                const totalWindows = config.windowsPerRow * config.rows;

                // Define window dimensions based on type
                let windowWidth, windowHeight;
                switch(config.windowType) {
                    case 'small':
                        windowWidth = 3;
                        windowHeight = 3;
                        break;
                    case 'wide':
                        windowWidth = 6;
                        windowHeight = 3;
                        break;
                    case 'tall':
                        windowWidth = 3;
                        windowHeight = 6;
                        break;
                    case 'square':
                    default:
                        windowWidth = 4;
                        windowHeight = 4;
                        break;
                }

                for (let i = 0; i < totalWindows; i++) {
                    const window = document.createElement('div');
                    window.className = 'window';

                    // Set window size
                    window.style.width = windowWidth + 'px';
                    window.style.height = windowHeight + 'px';

                    // Random green tone for each window (between #006600 and #00cc00)
                    const greenValue = Math.floor(102 + Math.random() * 102); // 102-204 range
                    const greenHex = greenValue.toString(16).padStart(2, '0');
                    window.style.backgroundColor = `#00${greenHex}00`;

                    // Randomly turn off some windows initially
                    if (Math.random() > 0.65) {
                        window.classList.add('off');
                    }

                    building.appendChild(window);
                }

                skyline.appendChild(building);
            });

            // Animate window lights randomly - multiple windows at once
            setInterval(() => {
                const windows = document.querySelectorAll('.nyc-skyline .window');
                // Toggle 8-12 random windows each time
                const numToToggle = 8 + Math.floor(Math.random() * 5);
                for (let i = 0; i < numToToggle; i++) {
                    const randomWindow = windows[Math.floor(Math.random() * windows.length)];
                    if (randomWindow) {
                        randomWindow.classList.toggle('off');
                    }
                }
            }, 250);
        }

        // Create credits screen stars
        function createCreditsStars() {
            const starCount = 30; // 크레딧 화면 별 개수
            creditsStars.innerHTML = '';

            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'credits-star';

                // 랜덤 위치 (상단 영역에만)
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 250 + 'px';

                // 랜덤 애니메이션 딜레이
                star.style.animationDelay = Math.random() * 2 + 's';

                // 랜덤 애니메이션 지속시간
                star.style.animationDuration = (1.5 + Math.random() * 2) + 's';

                creditsStars.appendChild(star);
            }
        }

        // Setup drag and drop for character portraits
        function setupCharacterUpload() {
            const charBoxes = document.querySelectorAll('.char-box');

            charBoxes.forEach((box, index) => {
                const canvas = box.querySelector('canvas');
                if (!canvas) return;

                // File input for click upload
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.style.display = 'none';
                document.body.appendChild(fileInput);

                // Click to upload
                box.addEventListener('click', () => {
                    fileInput.click();
                });

                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        processCharacterImage(file, canvas);
                    }
                });

                // Drag and drop
                box.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    box.classList.add('drag-over');
                });

                box.addEventListener('dragleave', () => {
                    box.classList.remove('drag-over');
                });

                box.addEventListener('drop', (e) => {
                    e.preventDefault();
                    box.classList.remove('drag-over');

                    const file = e.dataTransfer.files[0];
                    if (file && file.type.startsWith('image/')) {
                        processCharacterImage(file, canvas);
                    }
                });
            });
        }

        // Setup editable character names and roles
        function setupEditableText() {
            const charNames = document.querySelectorAll('.char-name');
            const charRoles = document.querySelectorAll('.char-role');

            function makeEditable(element) {
                element.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent triggering char-box click

                    // If already editing, don't create another
                    if (element.classList.contains('editing')) return;

                    const originalText = element.textContent;
                    element.classList.add('editing');
                    element.contentEditable = true;
                    element.focus();

                    // Select all text
                    const range = document.createRange();
                    range.selectNodeContents(element);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);

                    // Save on Enter or blur
                    const saveEdit = () => {
                        element.classList.remove('editing');
                        element.contentEditable = false;

                        // Remove empty text
                        if (element.textContent.trim() === '') {
                            element.textContent = originalText;
                        }

                        // Save to localStorage
                        saveCharacterData();
                    };

                    const handleKeydown = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            saveEdit();
                            element.removeEventListener('keydown', handleKeydown);
                            element.removeEventListener('blur', handleBlur);
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            element.textContent = originalText;
                            element.classList.remove('editing');
                            element.contentEditable = false;
                            element.removeEventListener('keydown', handleKeydown);
                            element.removeEventListener('blur', handleBlur);
                        }
                    };

                    const handleBlur = () => {
                        saveEdit();
                        element.removeEventListener('keydown', handleKeydown);
                        element.removeEventListener('blur', handleBlur);
                    };

                    element.addEventListener('keydown', handleKeydown);
                    element.addEventListener('blur', handleBlur);
                });
            }

            charNames.forEach(makeEditable);
            charRoles.forEach(makeEditable);
        }

        // Save character data to IndexedDB
        async function saveCharacterData() {
            const characters = [];

            for (let i = 1; i <= 6; i++) {
                const charName = document.querySelector(`.credits-character:nth-child(${i}) .char-name`);
                const charRole = document.querySelector(`.credits-character:nth-child(${i}) .char-role`);
                const canvas = document.getElementById(`char${i}Canvas`);

                characters.push({
                    name: charName ? charName.textContent : '',
                    role: charRole ? charRole.textContent : '',
                    image: canvas ? canvas.toDataURL() : null
                });
            }

            try {
                await diaryDB.saveCharacters(characters);
            } catch (e) {
                console.error('Failed to save character data:', e);
            }
        }

        // Load character data from IndexedDB
        async function loadCharacterData() {
            try {
                const characters = await diaryDB.getCharacters();
                if (!characters || characters.length === 0) return;

                characters.forEach((char, index) => {
                    const i = index + 1;
                    const charName = document.querySelector(`.credits-character:nth-child(${i}) .char-name`);
                    const charRole = document.querySelector(`.credits-character:nth-child(${i}) .char-role`);
                    const canvas = document.getElementById(`char${i}Canvas`);

                    if (charName && char.name) charName.textContent = char.name;
                    if (charRole && char.role) charRole.textContent = char.role;

                    if (canvas && char.image) {
                        const img = new Image();
                        img.onload = () => {
                            const ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        };
                        img.src = char.image;
                    }
                });
            } catch (e) {
                console.error('Failed to load character data:', e);
            }
        }

        // Language switching functionality
        function setupLanguageButtons() {
            const langButtons = document.querySelectorAll('.lang-button');

            langButtons.forEach(button => {
                button.addEventListener('click', async () => {
                    const lang = button.dataset.lang;

                    // Update active state
                    langButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');

                    // Save language to IndexedDB
                    try {
                        await diaryDB.saveSetting('language', lang);
                    } catch (e) {
                        console.error('Failed to save language setting:', e);
                    }

                    // Apply language
                    applyLanguage(lang);
                });
            });
        }

        async function loadLanguage() {
            let savedLang = 'ko';
            try {
                savedLang = await diaryDB.getSetting('language') || 'ko';
            } catch (e) {
                console.error('Failed to load language setting:', e);
            }
            applyLanguage(savedLang);

            // Update button state
            const langButtons = document.querySelectorAll('.lang-button');
            langButtons.forEach(btn => {
                if (btn.dataset.lang === savedLang) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function applyLanguage(lang) {
            const translations = {
                ko: {
                    menuWrite: '일기쓰기',
                    menuList: '나의 일기장',
                    menuCredits: '디스켓',
                    menuLogin: '로그인',
                    settingsButton: '⚙ Settings'
                },
                en: {
                    menuWrite: 'Diary',
                    menuList: 'Memory',
                    menuCredits: 'Diskette',
                    menuLogin: 'Login',
                    settingsButton: '⚙ Settings'
                }
            };

            const texts = translations[lang];

            // Update menu items
            const menuItems = document.querySelectorAll('.main-menu .menu-item');
            menuItems[0].textContent = texts.menuWrite;
            menuItems[1].textContent = texts.menuList;
            menuItems[2].textContent = texts.menuCredits;

            // Update auth menu item (only if not logged in)
            if (!bkendAPI.isLoggedIn()) {
                menuItems[3].textContent = texts.menuLogin;
            }

            // Update settings button
            const settingsButton = document.getElementById('settingsLinkButton');
            if (settingsButton) {
                settingsButton.textContent = texts.settingsButton;
            }
        }

        // Setup settings button in diary list
        function setupSettingsButton() {
            const settingsButton = document.getElementById('settingsLinkButton');
            if (settingsButton) {
                settingsButton.addEventListener('click', () => {
                    switchMode('settings');
                });
            }
        }

        // Create cars on the road
        function createCars() {
            const road = document.getElementById('road');
            if (!road) return;

            // Function to create a car canvas (sedan style)
            function createCarCanvas() {
                const canvas = document.createElement('canvas');
                canvas.width = 28;
                canvas.height = 14;
                const ctx = canvas.getContext('2d');

                const greenValue = 102 + Math.floor(Math.random() * 102);
                const greenHex = greenValue.toString(16).padStart(2, '0');
                const bodyColor = `#00${greenHex}00`;

                const darkGreen = Math.floor(greenValue * 0.6).toString(16).padStart(2, '0');
                const windowColor = `#00${darkGreen}00`;

                // Car body (rounded sedan shape)
                ctx.fillStyle = bodyColor;
                ctx.fillRect(4, 7, 20, 6); // main body
                ctx.fillRect(8, 4, 12, 4); // cabin

                // Windows
                ctx.fillStyle = windowColor;
                ctx.fillRect(9, 5, 4, 3); // front window
                ctx.fillRect(15, 5, 4, 3); // back window

                // Wheels (darker)
                ctx.fillStyle = '#003300';
                ctx.fillRect(6, 12, 3, 2);
                ctx.fillRect(19, 12, 3, 2);

                return canvas.toDataURL();
            }

            // Function to create a truck canvas
            function createTruckCanvas() {
                const canvas = document.createElement('canvas');
                canvas.width = 28;
                canvas.height = 14;
                const ctx = canvas.getContext('2d');

                const greenValue = 102 + Math.floor(Math.random() * 102);
                const greenHex = greenValue.toString(16).padStart(2, '0');
                const bodyColor = `#00${greenHex}00`;

                const darkGreen = Math.floor(greenValue * 0.6).toString(16).padStart(2, '0');
                const windowColor = `#00${darkGreen}00`;

                // Cargo area (back) - now on the left
                ctx.fillStyle = bodyColor;
                ctx.fillRect(2, 4, 16, 9); // larger cargo box

                // Cargo door lines
                ctx.fillStyle = '#003300';
                ctx.fillRect(2, 5, 1, 7);

                // Truck cabin (front) - now on the right
                ctx.fillStyle = bodyColor;
                ctx.fillRect(18, 7, 8, 6); // cabin

                // Window (front window)
                ctx.fillStyle = windowColor;
                ctx.fillRect(20, 8, 5, 3);

                // Front bumper/grille
                ctx.fillStyle = '#003300';
                ctx.fillRect(26, 9, 1, 3);

                // Wheels
                ctx.fillStyle = '#003300';
                ctx.fillRect(4, 12, 3, 2); // back wheel
                ctx.fillRect(22, 12, 3, 2); // front wheel

                return canvas.toDataURL();
            }

            // Spawn cars at random intervals
            setInterval(() => {
                const car = document.createElement('div');
                car.className = 'car';

                // Random vehicle type (70% car, 30% truck)
                const isTruck = Math.random() > 0.7;
                const vehicleCanvas = isTruck ? createTruckCanvas() : createCarCanvas();

                car.style.backgroundImage = `url(${vehicleCanvas})`;
                car.style.backgroundSize = 'contain';
                car.style.backgroundRepeat = 'no-repeat';

                // Random direction (50% each)
                const isLeftToRight = Math.random() > 0.5;

                if (isLeftToRight) {
                    car.classList.add('left-to-right', 'bottom-lane');
                } else {
                    car.classList.add('right-to-left', 'top-lane');
                }

                // Random speed (6-10 seconds)
                const duration = 6 + Math.random() * 4;
                car.style.animationDuration = duration + 's';

                road.appendChild(car);

                // Remove car after animation
                setTimeout(() => {
                    car.remove();
                }, duration * 1000);
            }, 1500); // Spawn new car every 1.5 seconds
        }

        // Extract first frame from GIF and convert to PNG
        async function extractGifFrame(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        resolve(canvas.toDataURL('image/png'));
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        // Check if file is GIF
        function isGifFile(file) {
            return file.type === 'image/gif' || file.name.toLowerCase().endsWith('.gif');
        }

        // Show crop modal and process image
        async function processCharacterImage(file, canvas) {
            let imageSrc;

            if (isGifFile(file)) {
                // Extract first frame from GIF
                imageSrc = await extractGifFrame(file);
            } else {
                // Regular image processing
                imageSrc = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
            }

            showCropModal(imageSrc, canvas);
        }

        // Setup and show crop modal
        function showCropModal(imageSrc, targetCanvas) {
            const cropModal = document.getElementById('cropModal');
            const cropPreview = document.getElementById('cropPreview');
            const cropSelection = document.getElementById('cropSelection');
            const cropConfirm = document.getElementById('cropConfirm');
            const cropCancel = document.getElementById('cropCancel');

            const img = new Image();

            img.onload = () => {
                // Show image
                cropPreview.src = imageSrc;
                cropModal.classList.add('active');

                // Calculate initial square crop (center)
                const maxSize = Math.max(img.width, img.height);
                const displayScale = Math.min(window.innerWidth * 0.8, window.innerHeight * 0.8) / maxSize;
                const displayWidth = img.width * displayScale;
                const displayHeight = img.height * displayScale;

                cropPreview.style.width = displayWidth + 'px';
                cropPreview.style.height = displayHeight + 'px';

                const size = Math.min(displayWidth, displayHeight);
                const left = (displayWidth - size) / 2;
                const top = (displayHeight - size) / 2;

                cropSelection.style.left = left + 'px';
                cropSelection.style.top = top + 'px';
                cropSelection.style.width = size + 'px';
                cropSelection.style.height = size + 'px';

                // Setup drag functionality
                setupCropDrag(cropSelection, cropPreview);

                // Confirm button
                cropConfirm.onclick = () => {
                    const rect = cropSelection.getBoundingClientRect();
                    const previewRect = cropPreview.getBoundingClientRect();

                    const scaleX = img.width / displayWidth;
                    const scaleY = img.height / displayHeight;

                    const cropX = (rect.left - previewRect.left) * scaleX;
                    const cropY = (rect.top - previewRect.top) * scaleY;
                    const cropSize = parseFloat(cropSelection.style.width) * scaleX;

                    applyCroppedImage(img, cropX, cropY, cropSize, targetCanvas);
                    cropModal.classList.remove('active');
                };

                // Cancel button
                cropCancel.onclick = () => {
                    cropModal.classList.remove('active');
                };
            };

            img.src = imageSrc;
        }

        // Setup crop drag and resize functionality
        function setupCropDrag(selection, preview) {
            let isDragging = false;
            let isResizing = false;
            let resizeHandle = null;
            let startX, startY, startLeft, startTop, startWidth, startHeight;

            // Drag to move
            selection.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('crop-handle')) {
                    // Start resizing
                    isResizing = true;
                    resizeHandle = e.target;
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = parseInt(selection.style.left);
                    startTop = parseInt(selection.style.top);
                    startWidth = selection.offsetWidth;
                    startHeight = selection.offsetHeight;
                    e.preventDefault();
                    return;
                }

                // Start dragging
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = parseInt(selection.style.left);
                startTop = parseInt(selection.style.top);
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    // Move selection
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    const newLeft = Math.max(0, Math.min(startLeft + deltaX, preview.offsetWidth - selection.offsetWidth));
                    const newTop = Math.max(0, Math.min(startTop + deltaY, preview.offsetHeight - selection.offsetHeight));

                    selection.style.left = newLeft + 'px';
                    selection.style.top = newTop + 'px';
                } else if (isResizing && resizeHandle) {
                    // Resize selection (maintaining square aspect ratio)
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    const handleClass = resizeHandle.className;
                    let newSize = startWidth;
                    let newLeft = startLeft;
                    let newTop = startTop;

                    if (handleClass.includes('se')) {
                        // Southeast: expand right/down
                        newSize = Math.max(50, startWidth + Math.max(deltaX, deltaY));
                    } else if (handleClass.includes('sw')) {
                        // Southwest: expand left/down
                        const delta = Math.max(-deltaX, deltaY);
                        newSize = Math.max(50, startWidth + delta);
                        newLeft = startLeft - (newSize - startWidth);
                    } else if (handleClass.includes('ne')) {
                        // Northeast: expand right/up
                        const delta = Math.max(deltaX, -deltaY);
                        newSize = Math.max(50, startWidth + delta);
                        newTop = startTop - (newSize - startWidth);
                    } else if (handleClass.includes('nw')) {
                        // Northwest: expand left/up
                        const delta = Math.max(-deltaX, -deltaY);
                        newSize = Math.max(50, startWidth + delta);
                        newLeft = startLeft - (newSize - startWidth);
                        newTop = startTop - (newSize - startWidth);
                    }

                    // Constrain to image bounds
                    if (newLeft < 0) {
                        newSize += newLeft;
                        newLeft = 0;
                    }
                    if (newTop < 0) {
                        newSize += newTop;
                        newTop = 0;
                    }
                    if (newLeft + newSize > preview.offsetWidth) {
                        newSize = preview.offsetWidth - newLeft;
                    }
                    if (newTop + newSize > preview.offsetHeight) {
                        newSize = preview.offsetHeight - newTop;
                    }

                    selection.style.width = newSize + 'px';
                    selection.style.height = newSize + 'px';
                    selection.style.left = newLeft + 'px';
                    selection.style.top = newTop + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
            });
        }

        // Apply cropped and pixelated image
        function applyCroppedImage(img, cropX, cropY, cropSize, targetCanvas) {
            const ctx = targetCanvas.getContext('2d');
            const pixelSize = 3;

            const w = Math.floor(cropSize / pixelSize);
            const h = Math.floor(cropSize / pixelSize);

            // Create temporary canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = false;

            // Draw cropped image
            tempCtx.drawImage(img, cropX, cropY, cropSize, cropSize, 0, 0, w, h);

            // Convert to green palette
            const imageData = tempCtx.getImageData(0, 0, w, h);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                const greenLevel = Math.floor(brightness / 51) * 51;

                data[i] = 0;
                data[i + 1] = greenLevel;
                data[i + 2] = 0;
            }

            tempCtx.putImageData(imageData, 0, 0);

            // Draw to final canvas
            ctx.clearRect(0, 0, 180, 180);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tempCanvas, 0, 0, 180, 180);

            // Save character data
            saveCharacterData();
        }

        // Load and pixelate character portraits (deprecated - using drag&drop now)
        function loadCharacterPortraits() {
            // This function is now deprecated
            // Users can drag and drop images directly onto character boxes
            return;

            characters.forEach((char) => {
                const canvas = document.getElementById(char.canvas);
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const img = new Image();

                // Set crossOrigin before setting src to avoid CORS issues
                img.crossOrigin = 'anonymous';

                img.onload = () => {
                    try {
                        // Pixelate effect
                        const pixelSize = 3;
                        const w = Math.floor(img.width / pixelSize);
                        const h = Math.floor(img.height / pixelSize);

                        // Create temporary canvas for pixelation
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = w;
                        tempCanvas.height = h;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.imageSmoothingEnabled = false;
                        tempCtx.drawImage(img, 0, 0, w, h);

                        // Get pixel data and convert to green palette
                        const imageData = tempCtx.getImageData(0, 0, w, h);
                        const data = imageData.data;

                        for (let i = 0; i < data.length; i += 4) {
                            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            const greenLevel = Math.floor(brightness / 51) * 51; // 5 levels

                            data[i] = 0;           // R
                            data[i + 1] = greenLevel; // G
                            data[i + 2] = 0;           // B
                        }

                        tempCtx.putImageData(imageData, 0, 0);

                        // Draw to final canvas
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(tempCanvas, 0, 0, 120, 120);
                    } catch (e) {
                        console.error('CORS error - please open HTML via local server:', e);
                        // Just draw the image without pixelation if CORS fails
                        ctx.drawImage(img, 0, 0, 120, 120);
                    }
                };

                img.onerror = (e) => {
                    console.error('Failed to load image:', char.url, e);
                    // Draw placeholder if image fails to load
                    ctx.fillStyle = '#001100';
                    ctx.fillRect(0, 0, 120, 120);
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(5, 5, 110, 110);

                    // Draw question marks
                    ctx.fillStyle = '#00ff00';
                    ctx.font = '48px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('?', 60, 60);
                };

                // Encode URL to handle spaces and special characters
                img.src = encodeURI(char.url);
            });
        }

        // ============================================
        // Auto-formatting Functions
        // ============================================

        // Generate divider based on longest line width
        function generateDivider(type) {
            // Find the longest line in the editor
            const lines = editor.value.split('\n');
            let maxWidth = 0;

            for (const line of lines) {
                const width = measureCtx.measureText(line).width;
                if (width > maxWidth) {
                    maxWidth = width;
                }
            }

            // Minimum width if no content or short content
            if (maxWidth < 200) {
                maxWidth = editor.clientWidth - 40;
            }

            if (type === 'dotted') {
                // "- " pattern (dash + space)
                const dashWidth = measureCtx.measureText('- ').width;
                const repeatCount = Math.floor(maxWidth / dashWidth);
                return Array(repeatCount).fill('-').join(' ');
            } else {
                // Solid underline
                const underscoreWidth = measureCtx.measureText('_').width;
                const repeatCount = Math.floor(maxWidth / underscoreWidth);
                return '_'.repeat(repeatCount);
            }
        }

        // Setup auto-formatting for editor
        function setupAutoFormatting() {
            editor.addEventListener('input', handleAutoFormat);
            editor.addEventListener('keydown', handleListContinuation);
            editor.addEventListener('keydown', handleTabKey);
            editor.addEventListener('dblclick', handleCheckboxToggle);
        }

        // Handle double-click to toggle checkbox
        function handleCheckboxToggle(e) {
            const pos = editor.selectionStart;
            const text = editor.value;

            // Find if we clicked on a checkbox character
            // Check a few characters around cursor position
            for (let i = Math.max(0, pos - 2); i <= Math.min(text.length - 1, pos + 2); i++) {
                const char = text[i];
                if (char === '□') {
                    // Toggle to checked
                    editor.value = text.substring(0, i) + '■' + text.substring(i + 1);
                    editor.selectionStart = editor.selectionEnd = pos;
                    updateCharCount();
                    return;
                } else if (char === '■') {
                    // Toggle to unchecked
                    editor.value = text.substring(0, i) + '□' + text.substring(i + 1);
                    editor.selectionStart = editor.selectionEnd = pos;
                    updateCharCount();
                    return;
                }
            }
        }

        // Handle Tab key - insert 4 spaces instead of default behavior
        function handleTabKey(e) {
            if (e.key !== 'Tab') return;

            e.preventDefault();
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const text = editor.value;
            const spaces = '    '; // 4 spaces

            editor.value = text.substring(0, start) + spaces + text.substring(end);
            editor.selectionStart = editor.selectionEnd = start + 4;
            updateCharCount();
            updateCursorPosition();
        }

        // Handle auto-formatting on input
        function handleAutoFormat(e) {
            const text = editor.value;
            const pos = editor.selectionStart;

            // Get current line
            let lineStart = pos;
            while (lineStart > 0 && text[lineStart - 1] !== '\n') {
                lineStart--;
            }
            const currentLine = text.substring(lineStart, pos);

            // Check for ----- (dotted divider)
            if (currentLine === '-----') {
                const before = text.substring(0, lineStart);
                const after = text.substring(pos);
                const divider = generateDivider('dotted');
                editor.value = before + divider + after;
                editor.selectionStart = editor.selectionEnd = lineStart + divider.length;
                updateCharCount();
                updateCursorPosition();
                return;
            }

            // Check for _____ (solid line)
            if (currentLine === '_____') {
                const before = text.substring(0, lineStart);
                const after = text.substring(pos);
                const solidLine = generateDivider('solid');
                editor.value = before + solidLine + after;
                editor.selectionStart = editor.selectionEnd = lineStart + solidLine.length;
                updateCharCount();
                updateCursorPosition();
                return;
            }

            // Check for "- " (bullet list)
            if (currentLine === '- ') {
                const before = text.substring(0, lineStart);
                const after = text.substring(pos);
                editor.value = before + '    • ' + after;
                editor.selectionStart = editor.selectionEnd = lineStart + 6;
                updateCharCount();
                updateCursorPosition();
                return;
            }

            // Check for "[] " (checkbox - unchecked)
            if (currentLine === '[] ') {
                const before = text.substring(0, lineStart);
                const after = text.substring(pos);
                editor.value = before + '    □ ' + after;
                editor.selectionStart = editor.selectionEnd = lineStart + 6;
                updateCharCount();
                updateCursorPosition();
                return;
            }

            // Check for "N. " (numbered list) - add 4 space indent
            const numberedMatch = currentLine.match(/^(\d+)\. $/);
            if (numberedMatch) {
                const num = numberedMatch[1];
                const before = text.substring(0, lineStart);
                const after = text.substring(pos);
                editor.value = before + '    ' + num + '. ' + after;
                editor.selectionStart = editor.selectionEnd = lineStart + 4 + num.length + 2;
                updateCharCount();
                updateCursorPosition();
                return;
            }
        }

        // Handle Enter key for list continuation
        function handleListContinuation(e) {
            if (e.key !== 'Enter') return;

            const text = editor.value;
            const pos = editor.selectionStart;

            // Get current line
            let lineStart = pos;
            while (lineStart > 0 && text[lineStart - 1] !== '\n') {
                lineStart--;
            }
            const currentLine = text.substring(lineStart, pos);

            // Check for bullet list (with 4 space indent)
            const bulletMatch = currentLine.match(/^(\s*)(•\s*)(.*)$/);
            if (bulletMatch) {
                const indent = bulletMatch[1];
                const bullet = bulletMatch[2];
                const content = bulletMatch[3];

                // If line is empty (just bullet), remove it and exit list
                if (content.trim() === '') {
                    e.preventDefault();
                    const before = text.substring(0, lineStart);
                    const after = text.substring(pos);
                    editor.value = before + after;
                    editor.selectionStart = editor.selectionEnd = lineStart;
                    updateCharCount();
                    updateCursorPosition();
                    return;
                }

                // Continue list with same indent
                e.preventDefault();
                const before = text.substring(0, pos);
                const after = text.substring(pos);
                const newText = before + '\n' + indent + '• ' + after;
                editor.value = newText;
                editor.selectionStart = editor.selectionEnd = pos + 1 + indent.length + 2;
                updateCharCount();
                updateCursorPosition();
                return;
            }

            // Check for checkbox list (with 4 space indent)
            const checkboxMatch = currentLine.match(/^(\s*)([□■]\s*)(.*)$/);
            if (checkboxMatch) {
                const indent = checkboxMatch[1];
                const checkbox = checkboxMatch[2];
                const content = checkboxMatch[3];

                // If line is empty (just checkbox), remove it and exit list
                if (content.trim() === '') {
                    e.preventDefault();
                    const before = text.substring(0, lineStart);
                    const after = text.substring(pos);
                    editor.value = before + after;
                    editor.selectionStart = editor.selectionEnd = lineStart;
                    updateCharCount();
                    updateCursorPosition();
                    return;
                }

                // Continue list with same indent (always unchecked for new item)
                e.preventDefault();
                const before = text.substring(0, pos);
                const after = text.substring(pos);
                const newText = before + '\n' + indent + '□ ' + after;
                editor.value = newText;
                editor.selectionStart = editor.selectionEnd = pos + 1 + indent.length + 2;
                updateCharCount();
                updateCursorPosition();
                return;
            }

            // Check for numbered list (with 4 space indent)
            const numberedMatch = currentLine.match(/^(\s*)(\d+)\.\s(.*)$/);
            if (numberedMatch) {
                const indent = numberedMatch[1];
                const num = parseInt(numberedMatch[2]);
                const content = numberedMatch[3];

                // If line is empty (just number), remove it and exit list
                if (content.trim() === '') {
                    e.preventDefault();
                    const before = text.substring(0, lineStart);
                    const after = text.substring(pos);
                    editor.value = before + after;
                    editor.selectionStart = editor.selectionEnd = lineStart;
                    updateCharCount();
                    updateCursorPosition();
                    return;
                }

                // Continue list with next number
                e.preventDefault();
                const before = text.substring(0, pos);
                const after = text.substring(pos);
                const nextNum = num + 1;
                const newText = before + '\n' + indent + nextNum + '. ' + after;
                editor.value = newText;
                editor.selectionStart = editor.selectionEnd = pos + 1 + indent.length + String(nextNum).length + 2;
                updateCharCount();
                updateCursorPosition();
                return;
            }
        }

        // Initialize
        async function init() {
            createStars();
            createCreditsStars();
            createNYCSkyline();
            createCars();

            // Wait for IndexedDB to be ready (for settings only)
            try {
                await diaryDB.waitForReady();
            } catch (e) {
                console.error('IndexedDB initialization failed:', e);
            }

            // Setup auth listeners first
            setupAuthListeners();

            // In local mode, skip auth and load entries directly
            if (!USE_SERVER_MODE) {
                updateAuthUI();
                await loadEntries();
                await updateTodayCount();
            } else {
                // Server mode: Try to restore session
                const sessionRestored = await tryRestoreSession();

                // Update auth UI regardless
                updateAuthUI();

                // Only load entries if logged in
                if (sessionRestored) {
                    await updateTodayCount();
                }
            }

            updateStatus();
            setupMenuListeners();
            setupTopMenuListeners();
            selectMenuItem(0);
            setupCursor();
            setupTextMeasurement();
            setupImageHandlers();
            setupImageModal();
            setupConfirmDialog();
            setupImportHandler();
            setupCharacterUpload();
            setupEditableText();
            await loadCharacterData();
            setupLanguageButtons();
            await loadLanguage();
            setupSettingsButton();
            setupCalendar();
            setupAutoFormatting();
            setupMarkdownMode();

            // Preload GIF for Christmas card download
            preloadGifData();
        }

        // =====================================================
        // MARKDOWN MODE FUNCTIONS
        // =====================================================

        // Initialize Mermaid with retro theme
        function initMermaid() {
            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({
                    startOnLoad: false,
                    theme: 'dark',
                    themeVariables: {
                        primaryColor: '#003300',
                        primaryTextColor: '#00ff00',
                        primaryBorderColor: '#00aa00',
                        lineColor: '#00aa00',
                        secondaryColor: '#001a00',
                        tertiaryColor: '#002200',
                        background: '#000000',
                        mainBkg: '#001a00',
                        secondBkg: '#002200',
                        border1: '#00aa00',
                        border2: '#004400',
                        arrowheadColor: '#00ff00',
                        fontFamily: 'NeoDunggeunmo, monospace',
                        fontSize: '14px',
                        textColor: '#00ff00',
                        nodeTextColor: '#00ff00'
                    }
                });
            }
        }

        // =====================================================
        // AUTH FUNCTIONS
        // =====================================================

        // Show loading overlay
        function showLoading(text = 'Loading...') {
            loadingOverlay.querySelector('.loading-text').textContent = text;
            loadingOverlay.classList.add('active');
        }

        // Hide loading overlay
        function hideLoading() {
            loadingOverlay.classList.remove('active');
        }

        // Update UI based on auth state
        function updateAuthUI() {
            const writeMenuItem = document.querySelector('.menu-item[data-action="write"]');
            const listMenuItem = document.querySelector('.menu-item[data-action="list"]');

            // In local mode, always enable everything
            if (!USE_SERVER_MODE) {
                userNickname.textContent = '로컬모드';
                authMenuItem.textContent = '로컬모드';
                authMenuItem.dataset.action = 'auth';
                if (writeMenuItem) writeMenuItem.classList.remove('disabled');
                if (listMenuItem) listMenuItem.classList.remove('disabled');
                return;
            }

            const isLoggedIn = bkendAPI.isLoggedIn();

            if (isLoggedIn) {
                // Show user info in menu bar
                userNickname.textContent = bkendAPI.getNickname();

                // Update title screen auth menu item
                authMenuItem.textContent = bkendAPI.getNickname();
                authMenuItem.dataset.action = 'logout';

                // Enable menu items
                if (writeMenuItem) writeMenuItem.classList.remove('disabled');
                if (listMenuItem) listMenuItem.classList.remove('disabled');
            } else {
                // Hide user info
                userNickname.textContent = '';

                // Update title screen auth menu item
                authMenuItem.textContent = '로그인';
                authMenuItem.dataset.action = 'auth';

                // Disable menu items
                if (writeMenuItem) writeMenuItem.classList.add('disabled');
                if (listMenuItem) listMenuItem.classList.add('disabled');
            }
        }

        // Update today's entry count display
        async function updateTodayCount() {
            // In local mode, count from local entries
            if (!USE_SERVER_MODE) {
                const today = new Date().toISOString().slice(0, 10);
                let count = 0;
                for (const key in entries) {
                    if (key.includes(today)) count++;
                }
                todayCount.textContent = `오늘 ${count}/100`;
                todayCount.classList.remove('warning', 'limit');
                if (count >= 100) {
                    todayCount.classList.add('limit');
                } else if (count >= 80) {
                    todayCount.classList.add('warning');
                }
                return;
            }

            // Server mode
            if (!bkendAPI.isLoggedIn()) {
                todayCount.textContent = '';
                return;
            }

            try {
                const count = await bkendAPI.getTodayCount();
                todayCount.textContent = `오늘 ${count}/100`;
                todayCount.classList.remove('warning', 'limit');
                if (count >= 100) {
                    todayCount.classList.add('limit');
                } else if (count >= 80) {
                    todayCount.classList.add('warning');
                }
            } catch (error) {
                console.error('Failed to get today count:', error);
            }
        }

        // Show auth screen
        function showAuthScreen() {
            titleScreen.style.display = 'none';
            authScreen.classList.add('active');
            authScreen.style.display = 'flex';
            appContainer.style.display = 'none';

            // Create stars for auth screen
            const authStars = document.getElementById('authStars');
            if (authStars) {
                authStars.innerHTML = '';
                for (let i = 0; i < 30; i++) {
                    const star = document.createElement('div');
                    star.className = 'star';
                    star.style.left = Math.random() * 100 + '%';
                    star.style.top = Math.random() * 100 + '%';
                    star.style.animationDelay = Math.random() * 3 + 's';
                    star.style.animationDuration = (2 + Math.random() * 2) + 's';
                    authStars.appendChild(star);
                }
            }

            // Reset form
            authNickname.value = '';
            authPin.value = '';
            authError.textContent = '';
            nicknameStatus.textContent = '';
            nicknameStatus.className = 'nickname-status';
        }

        // Hide auth screen
        function hideAuthScreen() {
            authScreen.classList.remove('active');
            authScreen.style.display = 'none';
            titleScreen.style.display = 'flex';
        }

        // Switch auth tab
        function switchAuthTab(tab) {
            isAuthMode = tab;
            const tabs = document.querySelectorAll('.auth-tab');
            tabs.forEach(t => t.classList.remove('active'));
            document.querySelector(`.auth-tab[data-tab="${tab}"]`).classList.add('active');

            authSubmitBtn.textContent = tab === 'login' ? '로그인' : '회원가입';
            authError.textContent = '';
            nicknameStatus.textContent = '';
            nicknameStatus.className = 'nickname-status';

            // Clear inputs
            authNickname.value = '';
            authPin.value = '';
        }

        // Check nickname availability (debounced)
        async function checkNickname(nickname) {
            if (isAuthMode !== 'signup') return;

            if (nickname.length < 2) {
                nicknameStatus.textContent = nickname.length > 0 ? '2자 이상 입력해주세요' : '';
                nicknameStatus.className = 'nickname-status';
                return;
            }

            if (nickname.length > 12) {
                nicknameStatus.textContent = '12자 이하로 입력해주세요';
                nicknameStatus.className = 'nickname-status taken';
                return;
            }

            // Show valid format (actual duplicate check happens at signup)
            nicknameStatus.textContent = '✓ 형식 확인됨';
            nicknameStatus.className = 'nickname-status available';

        }

        // Handle auth form submit
        async function handleAuthSubmit(e) {
            e.preventDefault();

            const nickname = authNickname.value.trim();
            const pin = authPin.value.trim();

            // Validate
            if (nickname.length < 2 || nickname.length > 12) {
                authError.textContent = '닉네임은 2-12자여야 합니다';
                return;
            }

            if (!/^\d{4}$/.test(pin)) {
                authError.textContent = 'PIN은 숫자 4자리여야 합니다';
                return;
            }

            showLoading(isAuthMode === 'login' ? '로그인 중...' : '회원가입 중...');
            authError.textContent = '';

            try {
                if (isAuthMode === 'login') {
                    await bkendAPI.signin(nickname, pin);
                } else {
                    await bkendAPI.signup(nickname, pin);
                }

                hideLoading();
                hideAuthScreen();
                updateAuthUI();

                // Load entries after login
                await loadEntries();
                await updateTodayCount();

            } catch (error) {
                hideLoading();
                console.error('Auth error:', error);

                // Safely extract error message as string
                let message = '';
                if (error && error.message) {
                    message = typeof error.message === 'string' ? error.message : JSON.stringify(error.message);
                } else if (typeof error === 'string') {
                    message = error;
                }

                // Handle network errors
                if (message === 'OFFLINE') {
                    authError.textContent = '인터넷 연결을 확인해주세요';
                } else if (message === 'NETWORK_ERROR') {
                    authError.textContent = '서버에 연결할 수 없습니다';
                } else if (message === 'SESSION_EXPIRED') {
                    authError.textContent = '세션이 만료되었습니다. 다시 로그인해주세요';
                } else {
                    // Handle auth-specific errors
                    const lowerMessage = message.toLowerCase();
                    if (lowerMessage.includes('invalid') || lowerMessage.includes('incorrect') || lowerMessage.includes('wrong')) {
                        authError.textContent = '닉네임 또는 PIN이 올바르지 않습니다';
                    } else if (lowerMessage.includes('exist') || lowerMessage.includes('duplicate') || lowerMessage.includes('already')) {
                        authError.textContent = '이미 존재하는 닉네임입니다';
                    } else if (lowerMessage.includes('not found') || lowerMessage.includes('user not')) {
                        authError.textContent = '존재하지 않는 사용자입니다';
                    } else if (lowerMessage.includes('password') || lowerMessage.includes('credentials')) {
                        authError.textContent = '닉네임 또는 PIN이 올바르지 않습니다';
                    } else {
                        authError.textContent = message || '오류가 발생했습니다';
                    }
                }
            }
        }

        // Handle logout
        function handleLogout() {
            bkendAPI.logout();
            entries = {};
            updateAuthUI();

            // Go back to title screen
            titleScreen.style.display = 'flex';
            appContainer.style.display = 'none';
            authScreen.style.display = 'none';

            showStatus('로그아웃 되었습니다', 2000);
        }

        // Setup auth event listeners
        function setupAuthListeners() {
            // Auth tabs
            document.querySelectorAll('.auth-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    switchAuthTab(tab.dataset.tab);
                });
            });

            // Form submit
            authForm.addEventListener('submit', handleAuthSubmit);

            // Back button
            authBack.addEventListener('click', hideAuthScreen);

            // Nickname check with debounce
            authNickname.addEventListener('input', () => {
                if (nicknameCheckTimeout) {
                    clearTimeout(nicknameCheckTimeout);
                }
                nicknameCheckTimeout = setTimeout(() => {
                    checkNickname(authNickname.value.trim());
                }, 500);
            });

            // PIN input - only allow numbers
            authPin.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/\D/g, '').slice(0, 4);
            });

            // Logout button
            logoutBtn.addEventListener('click', handleLogout);
        }

        // Try to restore session on load
        async function tryRestoreSession() {
            if (!bkendAPI.accessToken) return false;

            showLoading('세션 복원 중...');

            try {
                await bkendAPI.fetchCurrentUser();
                updateAuthUI();
                await loadEntries();
                await updateTodayCount();
                hideLoading();
                return true;
            } catch (error) {
                console.error('Session restore failed:', error);
                hideLoading();
                // Clear invalid session
                bkendAPI.logout();
                updateAuthUI();
                // Show error for network issues only
                if (error.message === 'OFFLINE' || error.message === 'NETWORK_ERROR') {
                    handleApiError(error);
                }
                return false;
            }
        }

        // Setup Markdown Mode
        function setupMarkdownMode() {
            initMermaid();

            // Mode toggle button click
            modeToggleBtn.addEventListener('click', toggleEditorMode);

            // Markdown toolbar buttons
            markdownToolbar.addEventListener('click', (e) => {
                const btn = e.target.closest('.md-tool-btn');
                if (!btn) return;

                const action = btn.dataset.action;
                handleMarkdownToolbarAction(action);
            });

            // Markdown editor input for live preview
            markdownEditor.addEventListener('input', () => {
                if (markdownPreviewVisible) {
                    renderMarkdownPreview();
                }
                updateMarkdownCharCount();
            });

            // Auto-save for markdown editor
            markdownEditor.addEventListener('input', () => {
                if (autoSaveTimeout) clearTimeout(autoSaveTimeout);
                autoSaveTimeout = setTimeout(() => {
                    saveCurrentMarkdownEntry();
                }, 2000);
            });
        }

        // Toggle between Diary and Markdown mode
        function toggleEditorMode() {
            // Save current content before switching
            if (editorMode === 'diary') {
                saveCurrentEntry();
            } else {
                saveCurrentMarkdownEntry();
            }

            editorMode = editorMode === 'diary' ? 'markdown' : 'diary';

            // Update UI
            if (editorMode === 'markdown') {
                modeToggleBtn.classList.add('markdown-active');
                modeLabel.textContent = 'MARKDOWN';
                modeLabel.classList.add('markdown-mode');
                diaryEditorWrapper.style.display = 'none';
                markdownEditorWrapper.style.display = 'flex';
                loadCurrentMarkdownEntry();
                markdownEditor.focus();
                showStatus('Markdown Mode - Press Ctrl+P for Preview');
            } else {
                modeToggleBtn.classList.remove('markdown-active');
                modeLabel.textContent = 'DIARY';
                modeLabel.classList.remove('markdown-mode');
                diaryEditorWrapper.style.display = 'flex';
                markdownEditorWrapper.style.display = 'none';
                loadCurrentEntry();
                editor.focus();
                showStatus('Diary Mode');
            }

            updateDateHeader();
        }

        // Get markdown entry key (prefixed with #)
        function getMarkdownEntryKey(date, number) {
            const baseKey = number === 1 ? date : `${date}_(${number})`;
            return `#${baseKey}`;
        }

        // Get current markdown entry key
        function getCurrentMarkdownEntryKey() {
            return getMarkdownEntryKey(currentDate, currentEntryNumber);
        }

        // Load current markdown entry
        function loadCurrentMarkdownEntry() {
            const key = getCurrentMarkdownEntryKey();
            const entry = entries[key];
            if (!entry) {
                markdownEditor.value = '';
            } else if (typeof entry === 'string') {
                markdownEditor.value = entry;
            } else {
                markdownEditor.value = entry.text || '';
            }
            lastSavedMarkdownContent = markdownEditor.value.trim();
            updateMarkdownCharCount();

            if (markdownPreviewVisible) {
                renderMarkdownPreview();
            }
        }

        // Save current markdown entry
        async function saveCurrentMarkdownEntry() {
            const content = markdownEditor.value.trim();
            const key = getCurrentMarkdownEntryKey();

            // 중복 저장 방지
            if (content === lastSavedMarkdownContent && content !== '') {
                showStatus('이미 저장되었습니다!', 2000);
                return;
            }

            if (!content) {
                if (entries[key]) {
                    delete entries[key];
                    await deleteEntrySingle(key);
                    showStatus('Saved!', 2000);
                }
                return;
            }

            if (!entries[key]) {
                entries[key] = { text: '', images: [] };
            }

            entries[key].text = content;
            await saveEntrySingle(key, entries[key]);
            showStatus('Saved!', 2000);
            lastSavedMarkdownContent = content;
            updateStatus();
        }

        // Update character count for markdown editor
        function updateMarkdownCharCount() {
            charCount.textContent = `${markdownEditor.value.length} chars`;
        }

        // Handle markdown toolbar actions
        function handleMarkdownToolbarAction(action) {
            const textarea = markdownEditor;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;
            const selectedText = text.substring(start, end);

            let insertion = '';
            let cursorOffset = 0;

            switch (action) {
                case 'heading':
                    insertion = `# ${selectedText}`;
                    cursorOffset = selectedText ? insertion.length : 2;
                    break;
                case 'bold':
                    insertion = `**${selectedText}**`;
                    cursorOffset = selectedText ? insertion.length : 2;
                    break;
                case 'italic':
                    insertion = `*${selectedText}*`;
                    cursorOffset = selectedText ? insertion.length : 1;
                    break;
                case 'code':
                    if (selectedText.includes('\n')) {
                        insertion = `\`\`\`\n${selectedText}\n\`\`\``;
                        cursorOffset = 4;
                    } else {
                        insertion = `\`${selectedText}\``;
                        cursorOffset = selectedText ? insertion.length : 1;
                    }
                    break;
                case 'link':
                    insertion = `[${selectedText || 'link text'}](url)`;
                    cursorOffset = selectedText ? insertion.length : 1;
                    break;
                case 'list':
                    insertion = `- ${selectedText}`;
                    cursorOffset = 2;
                    break;
                case 'quote':
                    insertion = `> ${selectedText}`;
                    cursorOffset = 2;
                    break;
                case 'table':
                    insertion = `| Header 1 | Header 2 | Header 3 |
|----------|----------|----------|
| Cell 1   | Cell 2   | Cell 3   |
| Cell 4   | Cell 5   | Cell 6   |`;
                    cursorOffset = insertion.length;
                    break;
                case 'mermaid':
                    insertion = `\`\`\`mermaid
flowchart LR
    A[Start] --> B[Process]
    B --> C[End]
\`\`\``;
                    cursorOffset = insertion.length;
                    break;
                case 'preview':
                    toggleMarkdownPreview();
                    return;
            }

            textarea.value = text.substring(0, start) + insertion + text.substring(end);
            textarea.selectionStart = textarea.selectionEnd = start + cursorOffset;
            textarea.focus();

            if (markdownPreviewVisible) {
                renderMarkdownPreview();
            }
        }

        // Toggle markdown preview
        function toggleMarkdownPreview() {
            markdownPreviewVisible = !markdownPreviewVisible;

            if (markdownPreviewVisible) {
                markdownPreview.style.display = 'block';
                previewToggleBtn.classList.add('active');
                previewToggleBtn.textContent = '✎ Edit';
                renderMarkdownPreview();
            } else {
                markdownPreview.style.display = 'none';
                previewToggleBtn.classList.remove('active');
                previewToggleBtn.textContent = '👁 Preview';
            }
        }

        // Render markdown preview with Mermaid support
        async function renderMarkdownPreview() {
            const content = markdownEditor.value;

            // Configure marked for GFM (GitHub Flavored Markdown)
            if (typeof marked !== 'undefined') {
                marked.setOptions({
                    gfm: true,
                    breaks: true,
                    tables: true
                });

                // Custom renderer for mermaid code blocks
                const renderer = new marked.Renderer();
                const originalCodeRenderer = renderer.code;

                renderer.code = function(code, language) {
                    if (language === 'mermaid') {
                        return `<div class="mermaid">${code}</div>`;
                    }
                    return `<pre><code class="language-${language || ''}">${escapeHtml(code)}</code></pre>`;
                };

                marked.setOptions({ renderer });

                markdownPreview.innerHTML = marked.parse(content);

                // Render Mermaid diagrams
                if (typeof mermaid !== 'undefined') {
                    try {
                        const mermaidDivs = markdownPreview.querySelectorAll('.mermaid');
                        for (let i = 0; i < mermaidDivs.length; i++) {
                            const div = mermaidDivs[i];
                            const code = div.textContent;
                            const id = `mermaid-${Date.now()}-${i}`;
                            try {
                                const { svg } = await mermaid.render(id, code);
                                div.innerHTML = svg;
                            } catch (e) {
                                div.innerHTML = `<pre style="color: #ff5555;">Mermaid Error: ${e.message}</pre>`;
                            }
                        }
                    } catch (e) {
                        console.error('Mermaid rendering error:', e);
                    }
                }
            }
        }

        // Escape HTML for code blocks
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Calendar functions
        function setupCalendar() {
            // Month navigation
            prevMonthBtn.addEventListener('click', () => {
                currentCalendarMonth--;
                if (currentCalendarMonth < 0) {
                    currentCalendarMonth = 11;
                    currentCalendarYear--;
                }
                renderCalendar();
                renderCalendarEntryList();
            });

            nextMonthBtn.addEventListener('click', () => {
                currentCalendarMonth++;
                if (currentCalendarMonth > 11) {
                    currentCalendarMonth = 0;
                    currentCalendarYear++;
                }
                renderCalendar();
                renderCalendarEntryList();
            });

            // Settings button
            settingsLinkButtonCalendar.addEventListener('click', () => {
                switchMode('settings');
            });
        }

        function renderCalendar() {
            const monthNames = ['JANUARY', 'FEBRUARY', 'MARCH', 'APRIL', 'MAY', 'JUNE',
                                'JULY', 'AUGUST', 'SEPTEMBER', 'OCTOBER', 'NOVEMBER', 'DECEMBER'];

            calendarTitle.textContent = `${monthNames[currentCalendarMonth]} ${currentCalendarYear}`;

            // Clear grid
            calendarGrid.innerHTML = '';

            // Day headers
            const dayHeaders = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
            dayHeaders.forEach(day => {
                const header = document.createElement('div');
                header.className = 'calendar-day-header';
                header.textContent = day;
                calendarGrid.appendChild(header);
            });

            // Get first day of month and total days
            const firstDay = new Date(currentCalendarYear, currentCalendarMonth, 1);
            const lastDay = new Date(currentCalendarYear, currentCalendarMonth + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startingDayOfWeek = firstDay.getDay();

            // Get previous month days
            const prevMonthLastDay = new Date(currentCalendarYear, currentCalendarMonth, 0);
            const prevMonthDays = prevMonthLastDay.getDate();

            // Today's date for highlighting
            const today = new Date();
            const isCurrentMonth = today.getFullYear() === currentCalendarYear && today.getMonth() === currentCalendarMonth;
            const todayDate = today.getDate();

            // Count entries per date (handle both diary and markdown entries)
            const entryCounts = {};
            Object.keys(entries).forEach(key => {
                const isMarkdown = key.startsWith('#');
                const actualKey = isMarkdown ? key.substring(1) : key;
                const parsed = parseEntryKey(actualKey);
                const date = parsed.date;
                entryCounts[date] = (entryCounts[date] || 0) + 1;
            });

            // Add previous month days
            for (let i = startingDayOfWeek - 1; i >= 0; i--) {
                const day = document.createElement('div');
                day.className = 'calendar-day other-month';
                day.textContent = prevMonthDays - i;
                calendarGrid.appendChild(day);
            }

            // Add current month days
            for (let date = 1; date <= daysInMonth; date++) {
                const day = document.createElement('div');
                day.className = 'calendar-day';
                day.textContent = date;

                // Check if today
                if (isCurrentMonth && date === todayDate) {
                    day.classList.add('today');
                }

                // Check if has entries
                const dateStr = `${currentCalendarYear}-${String(currentCalendarMonth + 1).padStart(2, '0')}-${String(date).padStart(2, '0')}`;
                const count = entryCounts[dateStr] || 0;

                if (count > 0) {
                    day.classList.add('has-entry');

                    // Add entry dot
                    const dot = document.createElement('span');
                    dot.className = 'entry-dot';
                    day.appendChild(dot);

                    // Click handler to load entry
                    day.addEventListener('click', () => {
                        loadEntryByDate(dateStr);
                    });
                }

                calendarGrid.appendChild(day);
            }

            // Add next month days to fill the grid
            const totalCells = 42; // 6 rows x 7 days
            const currentCells = startingDayOfWeek + daysInMonth;
            const remainingCells = totalCells - currentCells;

            for (let date = 1; date <= remainingCells; date++) {
                const day = document.createElement('div');
                day.className = 'calendar-day other-month';
                day.textContent = date;
                calendarGrid.appendChild(day);
            }

            // Render the entry list for this month
            renderCalendarEntryList();
        }

        function renderCalendarEntryList() {
            calendarEntryList.innerHTML = '';

            // Filter entries for current month (handle both diary and markdown entries)
            const monthEntries = Object.keys(entries).filter(key => {
                const isMarkdown = key.startsWith('#');
                const actualKey = isMarkdown ? key.substring(1) : key;
                const parsed = parseEntryKey(actualKey);
                const date = new Date(parsed.date + 'T00:00:00');
                return date.getFullYear() === currentCalendarYear && date.getMonth() === currentCalendarMonth;
            }).sort().reverse();

            if (monthEntries.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.style.color = '#555555';
                emptyMsg.style.textAlign = 'center';
                emptyMsg.style.marginTop = '30px';
                emptyMsg.textContent = 'No entries this month';
                calendarEntryList.appendChild(emptyMsg);
                return;
            }

            monthEntries.forEach(key => {
                const item = document.createElement('div');
                item.className = 'entry-item';
                item.dataset.entryKey = key;

                const isMarkdown = key.startsWith('#');
                const actualKey = isMarkdown ? key.substring(1) : key;
                const parsed = parseEntryKey(actualKey);
                const dateDiv = document.createElement('div');
                dateDiv.className = 'entry-date';
                const d = new Date(parsed.date + 'T00:00:00');
                const entryNumText = parsed.number > 1 ? ` (${parsed.number})` : '';

                // Add indicator for markdown entries
                dateDiv.innerHTML = isMarkdown
                    ? `<span style="color: #55ff55;">[MD]</span> ${d.getFullYear()}.${String(d.getMonth() + 1).padStart(2, '0')}.${String(d.getDate()).padStart(2, '0')}${entryNumText}`
                    : `${d.getFullYear()}.${String(d.getMonth() + 1).padStart(2, '0')}.${String(d.getDate()).padStart(2, '0')}${entryNumText}`;

                const preview = document.createElement('div');
                preview.className = 'entry-preview';

                const entry = entries[key];
                const text = typeof entry === 'string' ? entry : (entry.text || '');
                const imageCount = (entry.images && entry.images.length) ? ` [사진 ${entry.images.length}장]` : '';
                preview.textContent = text.substring(0, 100) + imageCount;

                item.appendChild(dateDiv);
                item.appendChild(preview);

                item.addEventListener('click', () => {
                    loadEntry(key);
                });

                calendarEntryList.appendChild(item);
            });
        }

        function loadEntryByDate(dateStr) {
            // Find all entries for this date (handle both diary and markdown entries)
            const dateEntries = Object.keys(entries).filter(key => {
                const isMarkdown = key.startsWith('#');
                const actualKey = isMarkdown ? key.substring(1) : key;
                const parsed = parseEntryKey(actualKey);
                return parsed.date === dateStr;
            }).sort();

            if (dateEntries.length === 0) return;

            // Load the first entry
            loadEntry(dateEntries[0]);
        }

        // Entry key management
        function getEntryKey(date, number) {
            return number === 1 ? date : `${date}_(${number})`;
        }

        function parseEntryKey(key) {
            const match = key.match(/^(.+)_\((\d+)\)$/);
            if (match) {
                return { date: match[1], number: parseInt(match[2]) };
            }
            return { date: key, number: 1 };
        }

        function getNextEntryNumber(date) {
            let maxNumber = 0;
            Object.keys(entries).forEach(key => {
                const parsed = parseEntryKey(key);
                if (parsed.date === date && parsed.number > maxNumber) {
                    maxNumber = parsed.number;
                }
            });
            return maxNumber + 1;
        }

        function getCurrentEntryKey() {
            return getEntryKey(currentDate, currentEntryNumber);
        }

        // Confirm Dialog
        function setupConfirmDialog() {
            confirmYes.addEventListener('click', () => {
                saveCurrentEntry();
                confirmDialog.classList.remove('active');
                proceedWithNewEntry();
            });

            confirmNo.addEventListener('click', () => {
                confirmDialog.classList.remove('active');
                proceedWithNewEntry();
            });
        }

        function checkUnsavedChanges() {
            const currentContent = editor.value.trim();
            return currentContent !== lastSavedContent;
        }

        function showConfirmDialog() {
            confirmDialog.classList.add('active');
        }

        function proceedWithNewEntry() {
            // First, ensure current entry is properly saved if needed
            // (already done by confirmYes or we're proceeding without saving)

            const today = new Date().toISOString().split('T')[0];
            currentDate = today;
            currentEntryNumber = getNextEntryNumber(today);

            // Clear editor BEFORE updating lastSavedContent
            editor.value = '';
            imagesContainer.innerHTML = '';

            // Hide images section
            const imagesSection = document.getElementById('imagesSection');
            if (imagesSection) {
                imagesSection.classList.remove('has-images');
            }

            // Update lastSavedContent to empty string so it matches editor
            lastSavedContent = '';

            updateDateHeader();
            updateCharCount();
            switchMode('view');
            hasUnsavedChanges = false;

            // Focus on editor
            editor.focus();
        }

        function setupTextMeasurement() {
            measureCanvas = document.createElement('canvas');
            measureCtx = measureCanvas.getContext('2d');
            measureCtx.font = '20px NeoDunggeunmo, monospace';
        }

        // Cursor management
        function setupCursor() {
            editor.addEventListener('input', updateCursorPosition);
            editor.addEventListener('click', updateCursorPosition);
            editor.addEventListener('keyup', updateCursorPosition);
            editor.addEventListener('keydown', updateCursorPosition);
            editor.addEventListener('scroll', updateCursorPosition);
            editor.addEventListener('focus', () => {
                cursor.style.display = 'block';
                updateCursorPosition();
            });
            editor.addEventListener('blur', () => {
                cursor.style.display = 'none';
            });
        }

        function updateCursorPosition() {
            const textBeforeCursor = editor.value.substring(0, editor.selectionStart);
            const lines = textBeforeCursor.split('\n');
            const currentLine = lines.length - 1;
            const currentLineText = lines[currentLine];

            // Use canvas to measure actual text width
            const textWidth = measureCtx.measureText(currentLineText).width;

            // Calculate line height based on CSS
            const lineHeight = 32; // 20px font-size * 1.6 line-height

            // Position block cursor at current character position (accounting for scroll)
            const topPosition = currentLine * lineHeight + 4 - editor.scrollTop;
            cursor.style.top = topPosition + 'px';
            cursor.style.left = textWidth + 'px';

            // Hide cursor if it's outside visible area
            if (topPosition < 0 || topPosition > editor.clientHeight) {
                cursor.style.display = 'none';
            } else if (document.activeElement === editor) {
                cursor.style.display = 'block';
            }
        }

        // Image handling
        function setupImageHandlers() {
            // File input change
            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
                fileInput.value = ''; // Reset
            });
        }

        function openImagePicker() {
            fileInput.click();
        }

        async function handleFiles(files) {
            for (let file of files) {
                if (!file.type.startsWith('image/')) continue;

                let imageSrc;
                if (isGifFile(file)) {
                    // Extract first frame from GIF
                    imageSrc = await extractGifFrame(file);
                } else {
                    // Regular image processing
                    imageSrc = await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.readAsDataURL(file);
                    });
                }
                pixelateImage(imageSrc);
            }
        }

        function pixelateImage(dataUrl) {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // Pixelate by scaling down then up
                const pixelSize = 3; // Lower = more pixels, higher = more pixelated
                const w = Math.floor(img.width / pixelSize);
                const h = Math.floor(img.height / pixelSize);

                // Draw small (pixelated base)
                canvas.width = w;
                canvas.height = h;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(img, 0, 0, w, h);

                // Get pixel data and reduce colors
                const imageData = ctx.getImageData(0, 0, w, h);
                const data = imageData.data;

                // Reduce to green palette
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const greenLevel = Math.floor(brightness / 64) * 64; // 4 levels

                    data[i] = 0;           // R
                    data[i + 1] = greenLevel; // G
                    data[i + 2] = 0;           // B
                }

                ctx.putImageData(imageData, 0, 0);

                // Create thumbnail (scale to 600px max for display)
                const thumbMaxSize = 600;
                const thumbScale = Math.min(thumbMaxSize / img.width, thumbMaxSize / img.height);
                const thumbW = Math.floor(img.width * thumbScale);
                const thumbH = Math.floor(img.height * thumbScale);

                const displayCanvas = document.createElement('canvas');
                displayCanvas.width = thumbW;
                displayCanvas.height = thumbH;
                const displayCtx = displayCanvas.getContext('2d');
                displayCtx.imageSmoothingEnabled = false;
                displayCtx.drawImage(canvas, 0, 0, thumbW, thumbH);

                // Create modal image (10x larger than original 150px = 1500px max)
                const modalMaxSize = 1500;
                const modalScale = Math.min(modalMaxSize / img.width, modalMaxSize / img.height);
                const modalW = Math.floor(img.width * modalScale);
                const modalH = Math.floor(img.height * modalScale);

                const modalCanvas = document.createElement('canvas');
                modalCanvas.width = modalW;
                modalCanvas.height = modalH;
                const modalCtx = modalCanvas.getContext('2d');
                modalCtx.imageSmoothingEnabled = false;
                modalCtx.drawImage(canvas, 0, 0, modalCanvas.width, modalCanvas.height);

                const thumbnailData = displayCanvas.toDataURL();
                const modalData = modalCanvas.toDataURL();
                addImageToEntry(thumbnailData, modalData);
            };
            img.src = dataUrl;
        }

        function addImageToEntry(thumbnailData, modalData) {
            const key = getCurrentEntryKey();
            if (!entries[key]) {
                entries[key] = { text: '', images: [] };
            }
            if (typeof entries[key] === 'string') {
                entries[key] = { text: entries[key], images: [] };
            }
            if (!entries[key].images) {
                entries[key].images = [];
            }

            entries[key].images.push({
                thumbnail: thumbnailData,
                full: modalData
            });
            saveEntries();
            displayImages();
            showStatus('Image added!', 2000);
        }

        function displayImages() {
            imagesContainer.innerHTML = '';
            const key = getCurrentEntryKey();
            const entry = entries[key];

            // Show or hide images section based on whether images exist
            if (!entry || !entry.images || entry.images.length === 0) {
                imagesSection.classList.remove('has-images');
                imagesContainer.removeAttribute('data-image-count');
                return;
            }

            imagesSection.classList.add('has-images');

            // Set image count for grid layout
            imagesContainer.setAttribute('data-image-count', entry.images.length);

            entry.images.forEach((imageData, index) => {
                const div = document.createElement('div');
                div.className = 'image-item';

                const img = document.createElement('img');
                // Handle both old format (string) and new format (object)
                if (typeof imageData === 'string') {
                    img.src = imageData;
                    img.onclick = () => openImageModal(imageData);
                } else {
                    img.src = imageData.thumbnail;
                    img.onclick = () => openImageModal(imageData.full);
                }

                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-image';
                removeBtn.textContent = 'X';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeImage(index);
                };

                div.appendChild(img);
                div.appendChild(removeBtn);
                imagesContainer.appendChild(div);
            });
        }

        function removeImage(index) {
            const key = getCurrentEntryKey();
            const entry = entries[key];
            if (entry && entry.images) {
                entry.images.splice(index, 1);
                saveEntries();
                displayImages();
                showStatus('Image removed', 2000);
            }
        }

        // Image Modal
        function setupImageModal() {
            modalClose.addEventListener('click', closeImageModal);
            imageModal.addEventListener('click', (e) => {
                if (e.target === imageModal) {
                    closeImageModal();
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && imageModal.classList.contains('active')) {
                    closeImageModal();
                }
            });
        }

        function openImageModal(dataUrl) {
            modalImage.src = dataUrl;
            imageModal.classList.add('active');

            // Remove scanning class first to reset animation
            modalImage.classList.remove('scanning');

            // Trigger reflow to restart animation
            void modalImage.offsetWidth;

            // Add scanning class to start animation
            modalImage.classList.add('scanning');
        }

        function closeImageModal() {
            imageModal.classList.remove('active');
            // Remove scanning class when closing
            modalImage.classList.remove('scanning');
            modalImage.src = '';
        }

        // Menu functions
        function setupMenuListeners() {
            menuItems.forEach((item, index) => {
                item.addEventListener('click', () => {
                    handleMenuAction(item.dataset.action);
                });
                item.addEventListener('mouseenter', () => {
                    selectMenuItem(index);
                });
            });
        }

        function setupTopMenuListeners() {
            topMenuItems.forEach(item => {
                item.addEventListener('click', () => {
                    handleTopMenuAction(item.dataset.action);
                });
            });
        }

        function handleTopMenuAction(action) {
            if (action === 'home') {
                returnToMenu();
            } else if (action === 'new') {
                newEntry();
            } else if (action === 'save') {
                saveCurrentEntry();
            } else if (action === 'list') {
                toggleDiaryList();
            } else if (action === 'picture') {
                togglePictureMenu();
            } else if (action === 'help') {
                switchMode('help');
            } else if (action === 'xmascard') {
                switchMode('xmascard');
            } else if (action === 'fullscreen') {
                toggleFullscreen();
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // Enter fullscreen
                const element = document.documentElement;
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.webkitRequestFullscreen) { // Safari
                    element.webkitRequestFullscreen();
                } else if (element.msRequestFullscreen) { // IE11
                    element.msRequestFullscreen();
                }
                showStatus('Press ESC to exit fullscreen', 3000);
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { // Safari
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { // IE11
                    document.msExitFullscreen();
                }
            }
        }

        function toggleDiaryList() {
            const isOpen = diaryListPanel.classList.contains('open');

            // Close picture menu if it's open
            if (pictureMenuPanel.classList.contains('open')) {
                pictureMenuPanel.classList.remove('open');
                document.removeEventListener('click', handlePictureMenuOutsideClick);
            }

            if (isOpen) {
                diaryListPanel.classList.remove('open');
                document.removeEventListener('click', handleOutsideClick);
            } else {
                renderDiaryListPanel();
                diaryListPanel.classList.add('open');
                // Add click listener after a short delay to prevent immediate closing
                setTimeout(() => {
                    document.addEventListener('click', handleOutsideClick);
                }, 100);
            }
        }

        function handleOutsideClick(e) {
            // Check if click is outside the diary list panel and List button
            if (!diaryListPanel.contains(e.target) &&
                !e.target.closest('[data-action="list"]') &&
                !e.target.closest('.menu-item-wrapper')) {
                diaryListPanel.classList.remove('open');
                document.removeEventListener('click', handleOutsideClick);
            }
        }

        function togglePictureMenu() {
            const isOpen = pictureMenuPanel.classList.contains('open');

            // Close diary list if it's open
            if (diaryListPanel.classList.contains('open')) {
                diaryListPanel.classList.remove('open');
                document.removeEventListener('click', handleOutsideClick);
            }

            if (isOpen) {
                pictureMenuPanel.classList.remove('open');
                document.removeEventListener('click', handlePictureMenuOutsideClick);
            } else {
                renderPictureMenu();
                pictureMenuPanel.classList.add('open');
                // Add click listener after a short delay to prevent immediate closing
                setTimeout(() => {
                    document.addEventListener('click', handlePictureMenuOutsideClick);
                }, 100);
            }
        }

        function handlePictureMenuOutsideClick(e) {
            // Check if click is outside the picture menu panel and Picture button
            if (!pictureMenuPanel.contains(e.target) &&
                !e.target.closest('[data-action="picture"]') &&
                !e.target.closest('.menu-item-wrapper')) {
                pictureMenuPanel.classList.remove('open');
                document.removeEventListener('click', handlePictureMenuOutsideClick);
            }
        }

        function renderPictureMenu() {
            pictureMenuPanel.innerHTML = '';

            // Add Picture option
            const addPictureOption = document.createElement('div');
            addPictureOption.className = 'menu-option';
            addPictureOption.textContent = 'Add Picture';
            addPictureOption.addEventListener('click', () => {
                pictureMenuPanel.classList.remove('open');
                document.removeEventListener('click', handlePictureMenuOutsideClick);
                openImagePicker();
            });
            pictureMenuPanel.appendChild(addPictureOption);

            // Get current entry to check if there are images
            const key = getCurrentEntryKey();
            const entry = entries[key];
            const hasImages = entry && entry.images && entry.images.length > 0;

            if (hasImages) {
                // View Images option (opens modal for first image or shows list)
                const viewImagesOption = document.createElement('div');
                viewImagesOption.className = 'menu-option';
                viewImagesOption.textContent = `View Images (${entry.images.length})`;
                viewImagesOption.addEventListener('click', () => {
                    pictureMenuPanel.classList.remove('open');
                    document.removeEventListener('click', handlePictureMenuOutsideClick);
                    // Open first image in modal
                    if (entry.images[0]) {
                        const imageData = entry.images[0];
                        if (typeof imageData === 'string') {
                            openImageModal(imageData);
                        } else {
                            openImageModal(imageData.full);
                        }
                    }
                });
                pictureMenuPanel.appendChild(viewImagesOption);
            }
        }

        function renderDiaryListPanel() {
            diaryListPanel.innerHTML = '';

            const keys = Object.keys(entries).sort().reverse();
            console.log('All entry keys:', keys);
            console.log('Total entries:', keys.length);

            if (keys.length === 0) {
                const noEntry = document.createElement('div');
                noEntry.style.padding = '20px';
                noEntry.style.color = '#00ff00';
                noEntry.textContent = 'No entries yet';
                diaryListPanel.appendChild(noEntry);
                return;
            }

            keys.forEach(key => {
                const item = document.createElement('div');
                item.className = 'list-item';

                const parsed = parseEntryKey(key);
                const dateSpan = document.createElement('span');
                dateSpan.className = 'list-date';
                const d = new Date(parsed.date + 'T00:00:00');
                const entryNumText = parsed.number > 1 ? ` (${parsed.number})` : '';
                dateSpan.textContent = `${d.getFullYear()}.${String(d.getMonth() + 1).padStart(2, '0')}.${String(d.getDate()).padStart(2, '0')}${entryNumText}`;

                const previewSpan = document.createElement('span');
                previewSpan.className = 'list-preview';
                const entry = entries[key];
                const text = typeof entry === 'string' ? entry : (entry.text || '');
                const imageCount = (entry.images && entry.images.length) ? ` [사진 ${entry.images.length}장]` : '';
                previewSpan.textContent = text.substring(0, 50) + (text.length > 50 ? '...' : '') + imageCount;

                item.appendChild(dateSpan);
                item.appendChild(previewSpan);

                item.addEventListener('click', () => {
                    loadEntry(key);
                    diaryListPanel.classList.remove('open');
                });

                diaryListPanel.appendChild(item);
            });
        }

        function selectMenuItem(index) {
            menuItems.forEach(item => item.classList.remove('selected'));
            menuItems[index].classList.add('selected');
            selectedMenuItem = index;
        }

        function handleMenuAction(action) {
            if (action === 'write') {
                // In local mode, skip login check
                if (USE_SERVER_MODE && !bkendAPI.isLoggedIn()) {
                    showAuthScreen();
                    return;
                }
                startApp('write');
            } else if (action === 'list') {
                // In local mode, skip login check
                if (USE_SERVER_MODE && !bkendAPI.isLoggedIn()) {
                    showAuthScreen();
                    return;
                }
                startApp('calendar');
            } else if (action === 'credits') {
                startApp('credits');
            } else if (action === 'auth') {
                if (USE_SERVER_MODE) {
                    showAuthScreen();
                } else {
                    showStatus('로컬 모드에서는 로그인이 필요 없습니다', 2000);
                }
            } else if (action === 'logout') {
                if (USE_SERVER_MODE) {
                    handleLogout();
                }
            }
        }

        function startApp(mode) {
            titleScreen.style.display = 'none';
            appContainer.style.display = 'flex';

            if (mode === 'write') {
                updateDateHeader();
                loadCurrentEntry();
                switchMode('view');
            } else if (mode === 'list') {
                switchMode('list');
            } else if (mode === 'calendar') {
                switchMode('calendar');
            } else if (mode === 'credits') {
                switchMode('credits');
            }
        }

        function returnToMenu() {
            saveCurrentEntry();
            appContainer.style.display = 'none';
            authScreen.style.display = 'none';
            titleScreen.style.display = 'flex';
            currentMode = 'title';
            selectMenuItem(0);
        }

        // Storage functions (using Bkend API in server mode, IndexedDB in local mode)
        async function loadEntries() {
            // In local mode, load from IndexedDB
            if (!USE_SERVER_MODE) {
                try {
                    showLoading('일기 불러오는 중...');
                    const storedEntries = await diaryDB.getAllEntries();
                    entries = storedEntries || {};
                    console.log('Loaded entries from IndexedDB:', Object.keys(entries).length);
                    hideLoading();
                } catch (error) {
                    console.error('Failed to load entries from IndexedDB:', error);
                    hideLoading();
                    entries = {};
                }
                return;
            }

            // Server mode - require login
            if (!bkendAPI.isLoggedIn()) {
                entries = {};
                return;
            }

            try {
                showLoading('일기 불러오는 중...');
                const serverEntries = await bkendAPI.getAllEntries();
                entries = {};

                // Convert server entries to local format
                serverEntries.forEach(entry => {
                    const key = generateLocalKey(entry.dateKey, entry.entryNumber, entry.type);
                    entries[key] = {
                        text: entry.text || '',
                        images: entry.images || [],
                        _id: entry._id, // Store Bkend ID for updates
                        dateKey: entry.dateKey,
                        entryNumber: entry.entryNumber,
                        type: entry.type
                    };
                });

                console.log('Loaded entries from Bkend:', Object.keys(entries).length);
                hideLoading();
            } catch (error) {
                console.error('Failed to load entries:', error);
                hideLoading();
                handleApiError(error);
                entries = {};
            }
        }

        // Generate local key from Bkend entry data
        function generateLocalKey(dateKey, entryNumber, type) {
            if (type === 'markdown') {
                if (entryNumber === 1) {
                    return `#${dateKey}`;
                } else {
                    return `#${dateKey}_(${entryNumber})`;
                }
            } else {
                if (entryNumber === 1) {
                    return dateKey;
                } else {
                    return `${dateKey}_(${entryNumber})`;
                }
            }
        }

        // Parse local key to get date information
        function parseLocalKey(key) {
            const isMarkdown = key.startsWith('#');
            const cleanKey = isMarkdown ? key.substring(1) : key;

            const match = cleanKey.match(/^(\d{4}-\d{2}-\d{2})(?:_\((\d+)\))?$/);
            if (match) {
                return {
                    dateKey: match[1],
                    entryNumber: match[2] ? parseInt(match[2]) : 1,
                    type: isMarkdown ? 'markdown' : 'diary'
                };
            }
            return null;
        }

        async function saveEntries() {
            // In local mode, save to IndexedDB
            if (!USE_SERVER_MODE) {
                try {
                    await diaryDB.saveAllEntries(entries);
                    showStatus('Saved!', 2000);
                } catch (error) {
                    console.error('Failed to save entries to IndexedDB:', error);
                    showStatus('저장 실패', 3000);
                }
                return;
            }
            // Not used with Bkend - entries are saved individually
            showStatus('Saved!', 2000);
        }

        async function saveEntrySingle(key, data) {
            // In local mode, save to IndexedDB
            if (!USE_SERVER_MODE) {
                try {
                    showStatus('Saving...', 0);
                    entries[key] = data;
                    await diaryDB.saveEntry(key, data);
                    showStatus('Saved!', 2000);
                } catch (error) {
                    console.error('Failed to save entry to IndexedDB:', error);
                    showStatus('저장 실패', 3000);
                }
                return;
            }

            // Server mode - require login
            if (!bkendAPI.isLoggedIn()) {
                showStatus('로그인이 필요합니다', 3000);
                return;
            }

            try {
                const parsed = parseLocalKey(key);
                if (!parsed) {
                    console.error('Invalid key format:', key);
                    return;
                }

                showStatus('Saving...', 0);

                if (data._id) {
                    // Update existing entry
                    await bkendAPI.updateEntry(data._id, {
                        text: data.text,
                        images: data.images || []
                    });
                } else {
                    // Create new entry
                    const newEntry = await bkendAPI.createEntry(
                        parsed.dateKey,
                        parsed.entryNumber,
                        parsed.type,
                        data.text,
                        data.images || []
                    );
                    // Store the new ID
                    if (newEntry && newEntry._id) {
                        entries[key]._id = newEntry._id;
                        entries[key].dateKey = parsed.dateKey;
                        entries[key].entryNumber = parsed.entryNumber;
                        entries[key].type = parsed.type;
                    }
                    await updateTodayCount();
                }

                showStatus('Saved!', 2000);
            } catch (error) {
                console.error('Failed to save entry:', error);
                handleApiError(error);
            }
        }

        async function deleteEntrySingle(key) {
            // In local mode, delete from IndexedDB
            if (!USE_SERVER_MODE) {
                try {
                    showStatus('Deleting...', 0);
                    delete entries[key];
                    await diaryDB.deleteEntry(key);
                    showStatus('Deleted!', 2000);
                } catch (error) {
                    console.error('Failed to delete entry from IndexedDB:', error);
                    showStatus('삭제 실패', 3000);
                }
                return;
            }

            // Server mode - require login
            if (!bkendAPI.isLoggedIn()) return;

            try {
                const entry = entries[key];
                if (entry && entry._id) {
                    showStatus('Deleting...', 0);
                    await bkendAPI.deleteEntry(entry._id);
                    await updateTodayCount();
                    showStatus('Deleted!', 2000);
                }
            } catch (error) {
                console.error('Failed to delete entry:', error);
                handleApiError(error);
            }
        }

        // Setup import file handler
        function setupImportHandler() {
            // In server mode, import is disabled
            if (USE_SERVER_MODE) {
                console.log('Import is disabled in server mode');
                return;
            }

            // In local mode, enable import from file
            const importInput = document.getElementById('importInput');
            if (importInput) {
                importInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        const text = await file.text();
                        const importedEntries = JSON.parse(text);
                        entries = { ...entries, ...importedEntries };
                        await diaryDB.saveAllEntries(entries);
                        showStatus('가져오기 완료!', 2000);
                    } catch (error) {
                        console.error('Import error:', error);
                        showStatus('가져오기 실패', 3000);
                    }
                });
            }
        }

        function loadCurrentEntry() {
            const key = getCurrentEntryKey();
            const entry = entries[key];
            if (!entry) {
                editor.value = '';
            } else if (typeof entry === 'string') {
                editor.value = entry;
            } else {
                editor.value = entry.text || '';
            }
            lastSavedContent = editor.value.trim();
            updateCharCount();
            displayImages();
        }

        async function saveCurrentEntry() {
            const content = editor.value.trim();
            const key = getCurrentEntryKey();
            const entry = entries[key];

            // 중복 저장 방지: 내용이 변경되지 않았으면 저장하지 않음
            if (content === lastSavedContent && content !== '') {
                showStatus('이미 저장되었습니다!', 2000);
                return;
            }

            console.log('saveCurrentEntry - key:', key, 'content length:', content.length);

            const hasImages = entry && entry.images && entry.images.length > 0;

            // Don't save if there's no content and no images
            if (!content && !hasImages) {
                // Only delete if the entry already exists in storage
                if (entries[key]) {
                    console.log('Deleting empty entry:', key);
                    delete entries[key];
                    await deleteEntrySingle(key);
                    showStatus('Saved!', 2000);
                }
                // Don't update lastSavedContent if there's nothing to save
                return;
            }

            // Save the entry - always create or update the entry at the current key
            if (!entries[key]) {
                entries[key] = { text: '', images: [] };
            }

            // Preserve existing images if any
            if (entry && entry.images) {
                entries[key].images = entry.images;
            } else if (!entries[key].images) {
                entries[key].images = [];
            }

            entries[key].text = content;

            console.log('Saved entry:', key);
            console.log('All keys after save:', Object.keys(entries));
            await saveEntrySingle(key, entries[key]);
            showStatus('Saved!', 2000);
            lastSavedContent = content;
        }

        // UI Updates
        function updateDateHeader() {
            const date = new Date(currentDate + 'T00:00:00');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const year = date.getFullYear();
            const daysOfWeek = ['SUNDAY', 'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY'];
            const dayOfWeek = daysOfWeek[date.getDay()];
            // Don't show entry number in diary view - only in list views
            const formatted = `${month}/${day}/${year} ${dayOfWeek}`;

            // Add mode indicator for markdown mode
            if (editorMode === 'markdown') {
                dateHeader.innerHTML = `<span style="color: #55ff55;">[MD]</span> ${formatted}`;
            } else {
                dateHeader.textContent = formatted;
            }
        }

        function updateCharCount() {
            charCount.textContent = `${editor.value.length} chars`;
        }

        function updateStatus() {
            entryCount.textContent = `${Object.keys(entries).length} entries`;
        }

        function showStatus(message, duration = 0) {
            statusLeft.textContent = message;
            if (duration > 0) {
                setTimeout(() => {
                    statusLeft.textContent = 'Ready';
                }, duration);
            }
        }

        // Handle API errors with user-friendly messages
        function handleApiError(error) {
            const message = error.message;

            if (message === 'OFFLINE') {
                showStatus('인터넷 연결을 확인해주세요', 5000);
                return;
            }

            if (message === 'NETWORK_ERROR') {
                showStatus('서버에 연결할 수 없습니다', 5000);
                return;
            }

            if (message === 'SESSION_EXPIRED') {
                showStatus('세션이 만료되었습니다', 3000);
                // Show auth screen after delay
                setTimeout(() => {
                    showAuthScreen();
                }, 1000);
                return;
            }

            // Default error message
            showStatus(message || '오류가 발생했습니다', 3000);
        }

        // Mode switching
        const xmasCardScreen = document.getElementById('xmasCardScreen');

        function switchMode(mode) {
            currentMode = mode;

            contentView.style.display = 'none';
            contentList.style.display = 'none';
            calendarContainer.style.display = 'none';
            helpScreen.style.display = 'none';
            settingsScreen.style.display = 'none';
            creditsScreen.style.display = 'none';
            xmasCardScreen.style.display = 'none';

            if (mode === 'view') {
                contentView.style.display = 'flex';
                editor.focus();
                updateCursorPosition();
                showStatus('Ready');
            } else if (mode === 'list') {
                renderEntryList();
                contentList.style.display = 'flex';
                showStatus('Select entry with arrow keys and ENTER');
            } else if (mode === 'calendar') {
                renderCalendar();
                calendarContainer.style.display = 'flex';
                showStatus('Click on a date to view entries');
            } else if (mode === 'help') {
                helpScreen.style.display = 'flex';
                showStatus('Press ESC to close help');
            } else if (mode === 'settings') {
                settingsScreen.style.display = 'flex';
                showStatus('⚙ Settings - Press ESC to return');
            } else if (mode === 'credits') {
                creditsScreen.style.display = 'flex';
                showStatus('💾 DOOGIE DISKETTE - Press ESC to return');
            } else if (mode === 'xmascard') {
                xmasCardScreen.style.display = 'flex';
                initXmasCardScreen();
                showStatus('🎄 Christmas Card - Press ESC to return');
            }
        }

        // Entry list
        function renderEntryList() {
            entryList.innerHTML = '';

            const sortedKeys = Object.keys(entries).sort().reverse();

            if (sortedKeys.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.style.color = '#aaaaaa';
                emptyMsg.style.textAlign = 'center';
                emptyMsg.style.marginTop = '50px';
                emptyMsg.textContent = '일기가 없습니다. F4를 눌러 새 일기를 작성하세요.';
                entryList.appendChild(emptyMsg);
                return;
            }

            sortedKeys.forEach(key => {
                const item = document.createElement('div');
                item.className = 'entry-item';
                item.dataset.entryKey = key;

                // Check if this is a markdown entry (starts with #)
                const isMarkdown = key.startsWith('#');
                const actualKey = isMarkdown ? key.substring(1) : key;

                const parsed = parseEntryKey(actualKey);
                const dateDiv = document.createElement('div');
                dateDiv.className = 'entry-date';
                const d = new Date(parsed.date + 'T00:00:00');
                const entryNumText = parsed.number > 1 ? ` (${parsed.number})` : '';

                // Add indicator for markdown entries
                const modeIndicator = isMarkdown ? '[MD] ' : '';
                dateDiv.innerHTML = isMarkdown
                    ? `<span style="color: #55ff55;">[MD]</span> ${d.getFullYear()}.${String(d.getMonth() + 1).padStart(2, '0')}.${String(d.getDate()).padStart(2, '0')}${entryNumText}`
                    : `${d.getFullYear()}.${String(d.getMonth() + 1).padStart(2, '0')}.${String(d.getDate()).padStart(2, '0')}${entryNumText}`;

                const preview = document.createElement('div');
                preview.className = 'entry-preview';

                const entry = entries[key];
                const text = typeof entry === 'string' ? entry : (entry.text || '');
                const imageCount = (entry.images && entry.images.length) ? ` [사진 ${entry.images.length}장]` : '';
                preview.textContent = text.substring(0, 100) + imageCount;

                item.appendChild(dateDiv);
                item.appendChild(preview);

                item.addEventListener('click', () => {
                    loadEntry(key);
                });

                entryList.appendChild(item);
            });

            // Add settings button at the end
            const footer = document.createElement('div');
            footer.className = 'list-footer';
            const settingsButton = document.createElement('button');
            settingsButton.className = 'settings-link-button';
            settingsButton.id = 'settingsLinkButton';
            settingsButton.textContent = '⚙ Settings';
            settingsButton.addEventListener('click', () => {
                switchMode('settings');
            });
            footer.appendChild(settingsButton);
            entryList.appendChild(footer);
        }

        function loadEntry(key) {
            // Save current entry BEFORE changing currentDate and currentEntryNumber
            const oldKey = editorMode === 'markdown' ? getCurrentMarkdownEntryKey() : getCurrentEntryKey();
            console.log('Switching from', oldKey, 'to', key);

            // Save based on current mode
            if (editorMode === 'markdown') {
                saveCurrentMarkdownEntry();
            } else {
                saveCurrentEntry();
            }

            // Check if this is a markdown entry (starts with #)
            if (key.startsWith('#')) {
                const actualKey = key.substring(1); // Remove # prefix
                const parsed = parseEntryKey(actualKey);
                currentDate = parsed.date;
                currentEntryNumber = parsed.number;

                // Switch to markdown mode if not already
                if (editorMode !== 'markdown') {
                    editorMode = 'markdown';
                    modeToggleBtn.classList.add('markdown-active');
                    modeLabel.textContent = 'MARKDOWN';
                    modeLabel.classList.add('markdown-mode');
                    diaryEditorWrapper.style.display = 'none';
                    markdownEditorWrapper.style.display = 'flex';
                }
                loadCurrentMarkdownEntry();
            } else {
                // Now switch to the new entry
                const parsed = parseEntryKey(key);
                currentDate = parsed.date;
                currentEntryNumber = parsed.number;

                // Switch to diary mode if not already
                if (editorMode !== 'diary') {
                    editorMode = 'diary';
                    modeToggleBtn.classList.remove('markdown-active');
                    modeLabel.textContent = 'DIARY';
                    modeLabel.classList.remove('markdown-mode');
                    diaryEditorWrapper.style.display = 'flex';
                    markdownEditorWrapper.style.display = 'none';
                }
                loadCurrentEntry();
            }

            console.log('New key is', getCurrentEntryKey());

            updateDateHeader();
            switchMode('view');
        }

        async function newEntry() {
            // Check 100 entries limit for today
            if (bkendAPI.isLoggedIn()) {
                try {
                    const canCreate = await bkendAPI.canCreateEntryToday();
                    if (!canCreate) {
                        showStatus('오늘은 더 이상 일기를 쓸 수 없습니다 (100/100)', 3000);
                        return;
                    }
                } catch (error) {
                    console.error('Failed to check entry limit:', error);
                }
            }

            // Check if there are unsaved changes
            if (checkUnsavedChanges()) {
                showConfirmDialog();
            } else {
                proceedWithNewEntry();
            }
        }

        // Auto-save
        editor.addEventListener('input', () => {
            updateCharCount();

            clearTimeout(autoSaveTimeout);
            autoSaveTimeout = setTimeout(() => {
                saveCurrentEntry();
                updateStatus();
            }, 2000);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Title screen navigation
            if (currentMode === 'title') {
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectMenuItem(Math.max(0, selectedMenuItem - 1));
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectMenuItem(Math.min(menuItems.length - 1, selectedMenuItem + 1));
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    handleMenuAction(menuItems[selectedMenuItem].dataset.action);
                }
                return;
            }

            // F1 - Help
            if (e.key === 'F1') {
                e.preventDefault();
                if (currentMode === 'help') {
                    switchMode('view');
                } else {
                    switchMode('help');
                }
            }

            // F2 - Save
            if (e.key === 'F2') {
                e.preventDefault();
                if (editorMode === 'markdown') {
                    saveCurrentMarkdownEntry();
                } else {
                    saveCurrentEntry();
                }
                updateStatus();
            }

            // F3 - List
            if (e.key === 'F3') {
                e.preventDefault();
                if (currentMode === 'list') {
                    switchMode('view');
                } else {
                    if (editorMode === 'markdown') {
                        saveCurrentMarkdownEntry();
                    } else {
                        saveCurrentEntry();
                    }
                    switchMode('list');
                }
            }

            // Ctrl+P or Cmd+P - Toggle markdown preview (only in markdown mode)
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'p' && editorMode === 'markdown' && currentMode === 'view') {
                e.preventDefault();
                toggleMarkdownPreview();
            }

            // Ctrl+M or Cmd+M - Toggle editor mode
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'm' && currentMode === 'view') {
                e.preventDefault();
                toggleEditorMode();
            }

            // F4 - New entry
            if (e.key === 'F4') {
                e.preventDefault();
                newEntry();
            }

            // F5 - Add picture
            if (e.key === 'F5') {
                e.preventDefault();
                if (currentMode === 'view') {
                    openImagePicker();
                }
            }

            // ESC - Return to menu or view
            if (e.key === 'Escape') {
                if (currentMode === 'view') {
                    returnToMenu();
                } else if (currentMode === 'credits') {
                    returnToMenu();
                } else if (currentMode === 'xmascard') {
                    switchMode('view');
                } else if (currentMode !== 'title') {
                    switchMode('view');
                }
            }
        });

        // Prevent accidental page close
        window.addEventListener('beforeunload', (e) => {
            if (editorMode === 'markdown') {
                saveCurrentMarkdownEntry();
            } else {
                saveCurrentEntry();
            }
        });

        // Start
        init();

        // ========== CHRISTMAS SPECIAL FEATURES ==========

        // Christmas State
        let christmasMode = localStorage.getItem('doogie_christmas_mode') === 'true';
        let bgmPlaying = false;
        let audioContext = null;
        let bgmOscillator = null;
        let bgmGain = null;

        // Initialize Christmas Features
        function initChristmas() {
            const xmasToggleBtn = document.getElementById('xmasToggleBtn');
            const bgmToggleBtn = document.getElementById('bgmToggleBtn');
            const xmasBgmSetting = document.getElementById('xmasBgmSetting');
            const easterEggModal = document.getElementById('easterEggModal');

            // Check if it's Christmas season (Dec 1-31)
            const today = new Date();
            const month = today.getMonth();
            const day = today.getDate();
            const isChristmasSeason = (month === 11); // December

            // Auto-enable during Christmas season
            if (isChristmasSeason && localStorage.getItem('doogie_christmas_mode') === null) {
                christmasMode = true;
                localStorage.setItem('doogie_christmas_mode', 'true');
            }

            // Apply Christmas mode if enabled
            if (christmasMode) {
                enableChristmasMode();
            }

            // Update button states on init
            updateXmasButtons();

            // Christmas toggle button in settings
            xmasToggleBtn.addEventListener('click', () => {
                christmasMode = !christmasMode;
                localStorage.setItem('doogie_christmas_mode', christmasMode.toString());
                if (christmasMode) {
                    enableChristmasMode();
                } else {
                    disableChristmasMode();
                }
                updateXmasButtons();
            });

            // BGM toggle button in settings
            bgmToggleBtn.addEventListener('click', () => {
                if (bgmPlaying) {
                    stopBGM();
                } else {
                    playBGM();
                }
                updateXmasButtons();
            });

            // Easter egg check for Christmas dates
            if (isChristmasSeason && (day === 24 || day === 25)) {
                showChristmasEasterEgg(day);
            }

            // Close easter egg modal
            document.addEventListener('keydown', (e) => {
                if (easterEggModal.classList.contains('show')) {
                    easterEggModal.classList.remove('show');
                }
            });

            easterEggModal.addEventListener('click', () => {
                easterEggModal.classList.remove('show');
            });
        }

        // Update Christmas button states
        function updateXmasButtons() {
            const xmasToggleBtn = document.getElementById('xmasToggleBtn');
            const bgmToggleBtn = document.getElementById('bgmToggleBtn');
            const xmasBgmSetting = document.getElementById('xmasBgmSetting');

            if (christmasMode) {
                xmasToggleBtn.textContent = 'ON';
                xmasToggleBtn.classList.add('active');
                xmasBgmSetting.style.display = 'flex';
            } else {
                xmasToggleBtn.textContent = 'OFF';
                xmasToggleBtn.classList.remove('active');
                xmasBgmSetting.style.display = 'none';
            }

            if (bgmPlaying) {
                bgmToggleBtn.textContent = 'ON';
                bgmToggleBtn.classList.add('active');
            } else {
                bgmToggleBtn.textContent = 'OFF';
                bgmToggleBtn.classList.remove('active');
            }
        }

        // Enable Christmas Mode
        function enableChristmasMode() {
            document.body.classList.add('christmas-theme');
            createSnowflakes();
            updateXmasButtons();
        }

        // Disable Christmas Mode
        function disableChristmasMode() {
            document.body.classList.remove('christmas-theme');
            clearSnowflakes();
            stopBGM();
            updateXmasButtons();
        }

        // Create Snowflakes
        function createSnowflakes() {
            const container = document.getElementById('snowContainer');
            container.innerHTML = '';

            const snowflakeChars = ['*', '❄', '❅', '❆', '•', '°'];

            for (let i = 0; i < 50; i++) {
                const snowflake = document.createElement('div');
                snowflake.className = 'snowflake';
                snowflake.textContent = snowflakeChars[Math.floor(Math.random() * snowflakeChars.length)];
                snowflake.style.left = Math.random() * 100 + '%';
                snowflake.style.animationDuration = (Math.random() * 3 + 4) + 's';
                snowflake.style.animationDelay = Math.random() * 5 + 's';
                snowflake.style.fontSize = (Math.random() * 10 + 6) + 'px';
                snowflake.style.opacity = Math.random() * 0.5 + 0.3;
                container.appendChild(snowflake);
            }
        }

        // Clear Snowflakes
        function clearSnowflakes() {
            const container = document.getElementById('snowContainer');
            container.innerHTML = '';
        }

        // 8-bit Christmas BGM - Rudolph the Red-Nosed Reindeer (루돌프 사슴코)
        let bgmInterval = null;

        function playBGM() {
            if (bgmPlaying) return;

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                bgmGain = audioContext.createGain();
                bgmGain.gain.value = 0.15;
                bgmGain.connect(audioContext.destination);

                // Rudolph the Red-Nosed Reindeer melody (루돌프 사슴코는 매우 반짝이는 코)
                const melody = [
                    // 루-돌-프 사-슴-코-는
                    { note: 'G4', duration: 1 },
                    { note: 'A4', duration: 0.5 },
                    { note: 'G4', duration: 0.5 },
                    { note: 'E4', duration: 1 },
                    { note: 'C5', duration: 1 },
                    { note: 'A4', duration: 1 },
                    { note: 'G4', duration: 2 },
                    // 매-우 반-짝-이-는 코
                    { note: 'G4', duration: 0.5 },
                    { note: 'A4', duration: 0.5 },
                    { note: 'G4', duration: 0.5 },
                    { note: 'A4', duration: 0.5 },
                    { note: 'G4', duration: 1 },
                    { note: 'C5', duration: 1 },
                    { note: 'B4', duration: 2 },
                    { note: null, duration: 0.5 },
                    // 만-일 네-가 봤-다-면
                    { note: 'F4', duration: 1 },
                    { note: 'G4', duration: 0.5 },
                    { note: 'F4', duration: 0.5 },
                    { note: 'D4', duration: 1 },
                    { note: 'B4', duration: 1 },
                    { note: 'A4', duration: 1 },
                    { note: 'G4', duration: 2 },
                    // 불-이 켜-진 다-고 했-겠-지
                    { note: 'G4', duration: 0.5 },
                    { note: 'A4', duration: 0.5 },
                    { note: 'G4', duration: 0.5 },
                    { note: 'A4', duration: 0.5 },
                    { note: 'G4', duration: 1 },
                    { note: 'A4', duration: 1 },
                    { note: 'E4', duration: 2 },
                    { note: null, duration: 1 },
                ];

                const noteFrequencies = {
                    'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
                    'G4': 392.00, 'A4': 440.00, 'B4': 493.88, 'C5': 523.25
                };

                let time = audioContext.currentTime;
                const tempo = 0.35; // calm tempo

                function playMelody() {
                    melody.forEach(({ note, duration }) => {
                        if (note === null) {
                            time += duration * tempo;
                            return;
                        }

                        const osc = audioContext.createOscillator();
                        const noteGain = audioContext.createGain();

                        osc.type = 'triangle';
                        osc.frequency.value = noteFrequencies[note];

                        const noteDuration = duration * tempo;
                        noteGain.gain.setValueAtTime(0.15, time);
                        noteGain.gain.setValueAtTime(0.15, time + noteDuration * 0.7);
                        noteGain.gain.linearRampToValueAtTime(0, time + noteDuration);

                        osc.connect(noteGain);
                        noteGain.connect(bgmGain);

                        osc.start(time);
                        osc.stop(time + noteDuration);

                        time += noteDuration;
                    });
                }

                playMelody();

                const melodyDuration = melody.reduce((sum, n) => sum + n.duration, 0) * tempo;
                bgmInterval = setInterval(() => {
                    time = audioContext.currentTime;
                    playMelody();
                }, melodyDuration * 1000);

                bgmPlaying = true;
                updateXmasButtons();

            } catch (e) {
                console.error('BGM Error:', e);
            }
        }

        // Stop BGM
        function stopBGM() {
            if (bgmInterval) {
                clearInterval(bgmInterval);
                bgmInterval = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            bgmPlaying = false;
            updateXmasButtons();
        }

        // Show Christmas Easter Egg
        function showChristmasEasterEgg(day) {
            const modal = document.getElementById('easterEggModal');
            const message = document.getElementById('easterEggMessage');

            if (day === 24) {
                message.innerHTML = `
                    <span class="gold">🌟 CHRISTMAS EVE 🌟</span><br><br>
                    <span class="white">내일은 크리스마스!</span><br>
                    <span style="font-size: 12px;">산타가 오늘 밤 출발한대요 🛷</span><br><br>
                    <span style="font-size: 10px; color: #888888;">- POPUP-STUDIO -</span>
                `;
            } else if (day === 25) {
                message.innerHTML = `
                    <span class="red">🎅 MERRY CHRISTMAS! 🎅</span><br><br>
                    <span class="gold">메리 크리스마스!</span><br>
                    <span class="white">행복한 하루 보내세요 ✨</span><br><br>
                    <span style="font-size: 12px;">🎁 선물 많이 받으세요! 🎁</span><br>
                    <span style="font-size: 10px; color: #888888;">- POPUP-STUDIO with ❤️ -</span>
                `;
            }

            // Show after a short delay
            setTimeout(() => {
                modal.classList.add('show');
            }, 2000);
        }

        // Initialize Christmas on load
        initChristmas();

        // ========== CHRISTMAS CARD FEATURES ==========

        let xmasCards = JSON.parse(localStorage.getItem('doogie_xmas_cards') || '[]');
        let currentCardId = null;

        function initXmasCardScreen() {
            const toInput = document.getElementById('cardToInput');
            const messageInput = document.getElementById('cardMessageInput');
            const fromInput = document.getElementById('cardFromInput');
            const toPreview = document.getElementById('cardToPreview');
            const messagePreview = document.getElementById('cardMessagePreview');
            const fromPreview = document.getElementById('cardFromPreview');

            // Real-time preview updates
            toInput.oninput = () => {
                toPreview.textContent = toInput.value || '_____';
            };
            messageInput.oninput = () => {
                messagePreview.textContent = messageInput.value || 'Write your message...';
            };
            fromInput.oninput = () => {
                fromPreview.textContent = fromInput.value || '_____';
            };

            // Button handlers
            document.getElementById('saveCardBtn').onclick = saveXmasCard;
            document.getElementById('downloadCardBtn').onclick = downloadXmasCard;
            document.getElementById('newCardBtn').onclick = newXmasCard;

            // Reset form
            newXmasCard();

            // Render saved cards list
            renderXmasCardList();
        }

        function newXmasCard() {
            currentCardId = null;
            document.getElementById('cardToInput').value = '';
            document.getElementById('cardMessageInput').value = '';
            document.getElementById('cardFromInput').value = '';
            document.getElementById('cardToPreview').textContent = '_____';
            document.getElementById('cardMessagePreview').textContent = 'Write your message...';
            document.getElementById('cardFromPreview').textContent = '_____';
        }

        function saveXmasCard() {
            const to = document.getElementById('cardToInput').value.trim();
            const message = document.getElementById('cardMessageInput').value.trim();
            const from = document.getElementById('cardFromInput').value.trim();

            if (!to || !message || !from) {
                showStatus('Please fill in all fields!', 3000);
                return;
            }

            const card = {
                id: currentCardId || Date.now().toString(),
                to,
                message,
                from,
                createdAt: new Date().toISOString()
            };

            if (currentCardId) {
                // Update existing
                const index = xmasCards.findIndex(c => c.id === currentCardId);
                if (index !== -1) {
                    xmasCards[index] = card;
                }
            } else {
                // Add new
                xmasCards.push(card);
                currentCardId = card.id;
            }

            localStorage.setItem('doogie_xmas_cards', JSON.stringify(xmasCards));
            renderXmasCardList();
            showStatus('🎄 Card saved!', 2000);
        }

        function loadXmasCard(id) {
            const card = xmasCards.find(c => c.id === id);
            if (!card) return;

            currentCardId = card.id;
            document.getElementById('cardToInput').value = card.to;
            document.getElementById('cardMessageInput').value = card.message;
            document.getElementById('cardFromInput').value = card.from;
            document.getElementById('cardToPreview').textContent = card.to;
            document.getElementById('cardMessagePreview').textContent = card.message;
            document.getElementById('cardFromPreview').textContent = card.from;
        }

        function deleteXmasCard(id) {
            xmasCards = xmasCards.filter(c => c.id !== id);
            localStorage.setItem('doogie_xmas_cards', JSON.stringify(xmasCards));
            if (currentCardId === id) {
                newXmasCard();
            }
            renderXmasCardList();
            showStatus('Card deleted', 2000);
        }

        function renderXmasCardList() {
            const listEl = document.getElementById('xmasCardList');
            listEl.innerHTML = '';

            if (xmasCards.length === 0) {
                listEl.innerHTML = '<div style="color: #555; text-align: center; padding: 20px;">No saved cards</div>';
                return;
            }

            xmasCards.forEach(card => {
                const item = document.createElement('div');
                item.className = 'xmas-card-list-item';
                item.innerHTML = `
                    <div class="xmas-card-list-item-info" data-id="${card.id}">
                        To: ${card.to} | From: ${card.from}
                    </div>
                    <span class="xmas-card-list-item-delete" data-id="${card.id}">✕</span>
                `;
                item.querySelector('.xmas-card-list-item-info').onclick = () => loadXmasCard(card.id);
                item.querySelector('.xmas-card-list-item-delete').onclick = (e) => {
                    e.stopPropagation();
                    deleteXmasCard(card.id);
                };
                listEl.appendChild(item);
            });
        }

        async function downloadXmasCard() {
            const to = document.getElementById('cardToInput').value.trim() || 'Friend';
            const from = document.getElementById('cardFromInput').value.trim() || 'Me';
            const cardFolder = document.querySelector('.xmas-card-folder');
            const gifImg = document.querySelector('.xmas-card-gif');

            if (!cardFolder) {
                showStatus('❌ Card not found', 2000);
                return;
            }

            showStatus('🎬 Creating GIF... (0%)', 10000);

            try {
                console.log('Starting GIF download...');
                console.log('GIF image src:', gifImg.src);
                console.log('Cached GIF buffer:', cachedGifArrayBuffer ? 'YES' : 'NO');

                // Load the original GIF and extract frames
                const gifFrames = await extractGifFramesFromUrl(gifImg.src);

                console.log('Extracted frames:', gifFrames.length);

                if (gifFrames.length === 0) {
                    console.log('No frames extracted, falling back to PNG');
                    // Fallback to PNG if GIF extraction fails
                    downloadXmasCardAsPng(to, from, cardFolder);
                    return;
                }

                // Create GIF encoder
                const gif = new GIF({
                    workers: 2,
                    quality: 10,
                    workerScript: 'gif.worker.js'
                });

                // Temporarily hide the GIF image for html2canvas
                const originalGifSrc = gifImg.src;

                // Capture each frame
                for (let i = 0; i < gifFrames.length; i++) {
                    // Replace GIF with current frame
                    gifImg.src = gifFrames[i].dataUrl;

                    // Wait for image to load
                    await new Promise(resolve => {
                        if (gifImg.complete) resolve();
                        else gifImg.onload = resolve;
                    });

                    // Capture the card
                    const canvas = await html2canvas(cardFolder, {
                        backgroundColor: '#000000',
                        scale: 1.5,
                        useCORS: true
                    });

                    gif.addFrame(canvas, { delay: gifFrames[i].delay || 100 });

                    const progress = Math.round(((i + 1) / gifFrames.length) * 100);
                    showStatus(`🎬 Creating GIF... (${progress}%)`, 10000);
                }

                // Restore original GIF
                gifImg.src = originalGifSrc;

                // Render and download
                gif.on('finished', function(blob) {
                    const link = document.createElement('a');
                    link.download = `christmas-card-to-${to}-from-${from}.gif`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(link.href);
                    showStatus('📥 GIF downloaded!', 2000);
                });

                gif.render();

            } catch (err) {
                console.error('GIF download error:', err);
                // Fallback to PNG
                downloadXmasCardAsPng(to, from, cardFolder);
            }
        }

        // Cache for preloaded GIF data
        let cachedGifArrayBuffer = null;
        let cachedGifDimensions = { width: 0, height: 0 };

        // Preload GIF data on page load (handles CORS for local files)
        async function preloadGifData() {
            const gifImg = document.querySelector('.xmas-card-gif');
            if (!gifImg) return;

            try {
                // Try XMLHttpRequest for local file access
                const arrayBuffer = await new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', gifImg.src, true);
                    xhr.responseType = 'arraybuffer';
                    xhr.onload = () => {
                        if (xhr.status === 200 || xhr.status === 0) {
                            resolve(xhr.response);
                        } else {
                            reject(new Error('XHR failed'));
                        }
                    };
                    xhr.onerror = () => reject(new Error('XHR error'));
                    xhr.send();
                });

                cachedGifArrayBuffer = arrayBuffer;
                cachedGifDimensions = { width: gifImg.naturalWidth || 300, height: gifImg.naturalHeight || 300 };
                console.log('GIF preloaded successfully');
            } catch (e) {
                console.log('GIF preload failed (will use file input fallback):', e.message);
            }
        }

        // Extract frames from GIF - uses cached data or prompts for file
        async function extractGifFramesFromUrl(url) {
            // If we have cached data, use it
            if (cachedGifArrayBuffer) {
                try {
                    const frames = await parseGifFrames(cachedGifArrayBuffer, cachedGifDimensions.width, cachedGifDimensions.height);
                    return frames;
                } catch (e) {
                    console.error('Failed to parse cached GIF:', e);
                }
            }

            // Fallback: prompt user to select the GIF file
            return new Promise((resolve) => {
                showStatus('📂 Please select card_dos.gif file', 5000);

                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/gif';

                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        resolve([]);
                        return;
                    }

                    try {
                        const arrayBuffer = await file.arrayBuffer();

                        // Get dimensions
                        const img = new Image();
                        const blob = new Blob([arrayBuffer], { type: 'image/gif' });
                        img.src = URL.createObjectURL(blob);

                        await new Promise(r => img.onload = r);

                        const frames = await parseGifFrames(arrayBuffer, img.naturalWidth, img.naturalHeight);
                        URL.revokeObjectURL(img.src);

                        // Cache for future use
                        cachedGifArrayBuffer = arrayBuffer;
                        cachedGifDimensions = { width: img.naturalWidth, height: img.naturalHeight };

                        resolve(frames);
                    } catch (err) {
                        console.error('Failed to process GIF file:', err);
                        resolve([]);
                    }
                };

                input.click();
            });
        }

        // Parse GIF frames using omggif
        async function parseGifFrames(arrayBuffer, width, height) {
            const frames = [];

            try {
                // Use omggif to parse GIF
                const uint8 = new Uint8Array(arrayBuffer);
                const gr = new GifReader(uint8);

                const numFrames = gr.numFrames();
                if (numFrames === 0) {
                    throw new Error('No frames found in GIF');
                }

                const gifWidth = gr.width;
                const gifHeight = gr.height;

                // Create a canvas to accumulate frames (for proper disposal handling)
                const accCanvas = document.createElement('canvas');
                accCanvas.width = gifWidth;
                accCanvas.height = gifHeight;
                const accCtx = accCanvas.getContext('2d', { willReadFrequently: true });

                // Process each frame
                for (let i = 0; i < numFrames; i++) {
                    const frameInfo = gr.frameInfo(i);

                    // Create pixel buffer for this frame
                    const frameCanvas = document.createElement('canvas');
                    frameCanvas.width = gifWidth;
                    frameCanvas.height = gifHeight;
                    const frameCtx = frameCanvas.getContext('2d', { willReadFrequently: true });

                    // Copy accumulated canvas first
                    frameCtx.drawImage(accCanvas, 0, 0);

                    // Decode frame pixels
                    const pixels = new Uint8Array(gifWidth * gifHeight * 4);
                    gr.decodeAndBlitFrameRGBA(i, pixels);

                    // Create ImageData and draw
                    const imageData = new ImageData(new Uint8ClampedArray(pixels), gifWidth, gifHeight);

                    // Create temp canvas for the frame data
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = gifWidth;
                    tempCanvas.height = gifHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(imageData, 0, 0);

                    // Draw frame onto frameCanvas (handles transparency)
                    frameCtx.drawImage(tempCanvas, 0, 0);

                    // Update accumulated canvas based on disposal method
                    if (frameInfo.disposal === 0 || frameInfo.disposal === 1) {
                        // Keep current frame
                        accCtx.drawImage(frameCanvas, 0, 0);
                    } else if (frameInfo.disposal === 2) {
                        // Restore to background (clear the frame area)
                        accCtx.clearRect(frameInfo.x, frameInfo.y, frameInfo.width, frameInfo.height);
                    }
                    // disposal === 3 means restore to previous - we skip that for simplicity

                    // Output canvas (scaled to target dimensions)
                    const outputCanvas = document.createElement('canvas');
                    outputCanvas.width = width;
                    outputCanvas.height = height;
                    const outputCtx = outputCanvas.getContext('2d');
                    outputCtx.drawImage(frameCanvas, 0, 0, width, height);

                    frames.push({
                        dataUrl: outputCanvas.toDataURL('image/png'),
                        delay: frameInfo.delay * 10 || 100 // GIF delay is in centiseconds
                    });
                }

                console.log(`Extracted ${frames.length} frames from GIF`);
                return frames;

            } catch (e) {
                console.error('omggif parsing failed:', e);

                // Fallback: single frame from image
                const img = new Image();
                img.src = URL.createObjectURL(new Blob([arrayBuffer], { type: 'image/gif' }));

                await new Promise(resolve => {
                    img.onload = resolve;
                });

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);

                URL.revokeObjectURL(img.src);

                return [{ dataUrl: canvas.toDataURL('image/png'), delay: 100 }];
            }
        }

        // Fallback PNG download (captures only message area to avoid CORS issues)
        function downloadXmasCardAsPng(to, from, element) {
            showStatus('📸 Capturing as PNG...', 2000);

            // Capture only the top panel (message area) to avoid GIF CORS issue
            const topPanel = document.querySelector('.xmas-card-top-panel');
            const targetElement = topPanel || element;

            html2canvas(targetElement, {
                backgroundColor: '#000000',
                scale: 2,
                useCORS: false,
                allowTaint: false
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = `christmas-card-to-${to}-from-${from}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                showStatus('📥 Card downloaded as PNG!', 2000);
            }).catch(err => {
                console.error('PNG download error:', err);
                showStatus('❌ Download failed - try running on a local server', 3000);
            });
        }

        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                const testLine = currentLine + word + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && currentLine !== '') {
                    lines.push(currentLine.trim());
                    currentLine = word + ' ';
                } else {
                    currentLine = testLine;
                }
            });
            lines.push(currentLine.trim());
            return lines;
        }
    </script>
</body>
</html>
